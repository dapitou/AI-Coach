# 课程生成逻辑
> **文档用途**：本文档是算法落地的“施工图纸”。
> - **产品经理**：请重点关注“业务导读”和“场景示例”，确认逻辑是否符合业务预期。
> - **开发人员**：请重点关注“输入/输出”和“处理逻辑”，这是代码实现的直接依据。
> **设计原则**：高内聚，低耦合。每个节点仅依赖明确的输入，产出标准化的输出。

## 节点流转总览
```mermaid
graph LR
    N1[输入与上下文] --> N2[课程确认]
    N2 --> N3[环节确认]
    N3 --> N4[动作确认]
    N4 --> N5[动作实例化]
    N5 --> N6[用户微调]
    N6 --> N7[数据装配]
    N7 --> N8[反馈闭环]
```

---

## 节点 1: 输入与上下文
> 定义：确立课程生成的“主干意图”（来源：用户或计划）与“边界约束”（来源：环境与状态）。
> > *业务导读*：就像教练在开课前进行的“摸底访谈”。系统需要收集你的基本信息、当下的需求（想练哪里、练多久）以及限制条件（有没有受伤、有什么器械），把这些信息打包成一个“上下文包”，传给后面的环节。

### 1. 输入数据
- **用户档案** (来源: 运动档案)：
    -   *基础数据*：`性别`、`生日`、`身高`、`体重`、`BMI`、`静息心率（RHR）`、`最大心率（MHR）`、`主观疲劳度`。
    -   *偏好设置*：`运动等级`、`每周训练日`、`每周运动频率`、`每日运动时长`、`疼痛部位`、`没有的器械`。
    -   *目标设定*：`主要目标`、`功能目标`、`目标体型`、`目标体重`。
    -   *能力数据*：`1RM记录`。
- **场景入口**：
    -   *用户输入* (单课模式)：`课程类型`、`目标部位`、`单课时长`、`单课环节` (热身/主训/放松，默认全选)。
    -   *计划上下文* (计划模式)：`课程类型`、`侧重维度`、`侧重目标`、`课程时长`、`单课环节`、`环节模板`、`阶段目标`、`阶段系数` (强度/容量)。
- **状态数据**：`综合疲劳度`、`部位状态值`。

### 2. 处理逻辑
1.  **步骤 1: 训练意图解析**
    > *目的：统一“计划模式”与“单课模式”的输入差异，输出标准化的训练需求。*
    -   **计划模式**：解析计划上下文中的参数。
        -   *规则*：若 `计划上下文` 存在。
        -   *规则*：`来源模式` = "计划"。
        -   *规则*：`基准类型` = `计划上下文.课程类型`。
        -   *规则*：`基准目标` = [`计划上下文.侧重目标`] (标准化为列表)。
        -   *规则*：`基准时长` = `计划上下文.课程时长`。
        -   *规则*：`基准环节` = `计划上下文.单课环节`。
    -   **单课模式**：解析用户输入的单课参数。
        -   *规则*：若不存在 `计划上下文`。
        -   *规则*：`来源模式` = "单课"。
        -   *规则*：`基准类型` = `用户输入.课程类型`。
        -   *规则*：`基准目标` = `用户输入.目标部位`。
        -   *规则*：`基准时长` = `用户输入.单课时长` (若空 → 取 `档案.每日运动时长`)。
        -   *规则*：`基准环节` = `用户输入.单课环节` (若空 → 默认 ["热身", "主训", "放松"])。

2.  **步骤 2: 限制条件识别**
    > *目的：识别身体和环境的红线，确保生成的课程安全可行。*
    -   **疲劳风控**：基于疲劳度识别风险。
        -   *规则*：`全局`：若 `综合疲劳度` < 55 → 标记 `推荐降级`（难度降低） = True。
        -   *规则*：`局部`：识别 `力竭部位` (`部位状态值` < 30)。
        -   *规则*：`智能推荐部位`：识别 `部位状态值` > 85 (已恢复) 的部位集合。
    -   **硬件环境**：计算可用器械集合。
        -   *规则*：`可用器械` = `全量器械库` - `档案.没有的器械`。
    -   **身体限制**：聚合所有禁忌部位。
        -   *规则*：`禁忌部位` = `档案.疼痛部位` ∪ `力竭部位` (来自疲劳风控)。

3.  **步骤 3: 智能缺口填充**
    > *目的：当用户输入不完整时，基于算法自动补全最优策略。*
    -   **类型补全**：自动推导缺失的课程类型。
        -   *规则*：若 `基准类型` 为空 → 基于 `档案.功能目标` 映射 (如: 增肌->力量, 减脂->HIIT)。
    -   **目标补全**：自动推荐缺失的训练目标。
        -   *规则*：若 `基准目标` 为空 → 优先推荐 `智能推荐部位` (状态好)；若无 `智能推荐部位` (全身疲劳) → 默认 "恢复" (主动恢复)。
    -   **时长补全**：设定默认时长。
        -   *规则*：若 `基准时长` 为空 → 默认 30min。

4.  **步骤 4: 数据完整性校验**
    > *目的：最后一道防线，防止脏数据进入下游。*
    -   **完整性校验**：确保核心参数不为空。
        -   *规则*：校验 `基准目标` && `基准时长` && `基准环节` 及核心档案字段。

### 3. 输出数据
- **上下文对象**：
    -   *基础上下文*：`来源模式`、`计划上下文`。
    -   *基准参数*：`基准类型`、`基准目标`、`基准时长`、`基准环节`。
    -   *约束条件*：`可用器械`、`禁忌部位`、`智能推荐部位`、`推荐降级`。
    -   *状态数据*：`状态数据`。

### 4. 场景示例 
> **场景**：一个膝盖有伤的用户，单课模式想练胸，只有哑铃，且时间紧迫只做主训。
> - **输入**：课程类型="力量"，目标部位="胸部"，单课环节=["主训"]，档案.疼痛部位="膝盖"，档案.没有的器械=["杠铃", "固定器械"]。
> - **输出**：
>   - `基准类型`: 力量
>   - `基准目标`: ["胸部"]
>   - `基准时长`: 30 (默认补全)
>   - `基准环节`: ["主训"]
>   - `可用器械`: ["哑铃", "自重"]
>   - `禁忌部位`: ["膝盖"] (后续会剔除深蹲等动作)
>   - `推荐降级`: False
>   - `状态数据`: 正常
>   - `计划上下文`: Null

---

## 节点 2: 课程确认
> 定义：基于上下文环境，裁决并确立课程的宏观属性。
> > *业务导读*：给这节课定调。确定主题是“增肌”还是“减脂”，难度是“入门”还是“专业”。

### 1. 输入数据
- **上下文对象** (来源: 节点 1)：
    -   `来源模式` (单节课/计划课)、`基准类型`、`基准目标`、`基准时长`、`推荐降级`、`计划上下文` (计划课专用)。
- **用户档案** (来源: 运动档案)：
    -   *偏好设置*：`运动等级`。
    -   *目标设定*：`功能目标`。

### 2. 处理逻辑
1.  **步骤 1: 目标冲突裁决**
    > *目的：解决“想练的部位”和“不能练的部位”之间的冲突。*
    -   **冲突检测**：检查目标部位是否在禁忌列表中。
        -   *规则*：检查 `上下文.基准目标` ∩ `上下文.禁忌部位` ≠ Ø。
    -   **冲突处理**：根据来源模式执行不同的冲突解决策略。
        -   *规则*：**计划模式**：触发 `部位替换策略` (如：胸部力竭 → 改练 `智能推荐部位` 或 "主动恢复")。
        -   *规则*：**单课模式**：前端提示风险 → 若用户坚持 → 标记 `推荐降级` = True；若用户接受建议 → `最终目标` = `智能推荐部位`。
    -   **最终定案**：输出经过裁决的目标部位。
        -   *规则*：输出 `最终目标部位`。

2.  **步骤 2: 难度基准定级**
    > *目的：确定课程的难度等级，并根据状态进行降级保护。*
    -   **确立基准**：根据用户档案设定初始难度。
        -   *规则*：`课程难度` = `档案.运动等级` (如 L3)。
    -   **执行修正**：处理降级逻辑。
        -   *规则*：若 `上下文.推荐降级` == True → `课程难度` 下调 2级 (最低 L1)。

3.  **步骤 3: 属性初始化**
    > *目的：补全课程类型、时长和生理目标。*
    -   **课程类型**：确定课程的运动种类。
        -   *规则*：`上下文.基准类型` (若空 → 映射自 `档案.功能目标`)。
    -   **课程时长**：确定课程总时长。
        -   *规则*：`上下文.基准时长`。
    -   **课程目标**：确定课程的生理训练目标。
        -   *规则*：若 `计划上下文` 存在：
            -   若 `计划上下文.侧重维度` == "动作功能" → 取 `计划上下文.侧重目标` (如: 计划是增肌，但此槽位是心肺)。
            -   否则 → 取 `计划上下文.阶段目标`。
        -   *规则*：否则 (单课模式) → 取 `档案.功能目标`。
    -   **目标部位**：确定训练部位。
        -   *规则*：若 `课程类型` ∈ [HIIT, 有氧] → 强制覆写为 ["全身"]。
        -   *规则*：否则 → 取 `上下文.基准目标`。

4.  **步骤 4: 解剖部位解析**
    > *目的：将抽象的动作模式（如水平推）翻译成具体的肌肉部位（如胸部）。*
    -   **解析逻辑**：将抽象维度转换为具体解剖部位。
        -   *规则*：若 `最终目标部位` 为 "动作模式" (如水平推) → 查阅 `[数据映射.md] - [动作模式与主练部位映射]` → 转换为 `解剖部位`。
        -   *规则*：若 `最终目标部位` 为 "动作功能" (如心肺) → 转换为 "全身"。

### 3. 输出数据
- **课程元数据** (流转至: 节点 3)：
    -   *推荐标签*：`课程类型`、`课程目标`、`目标部位`、`课程难度`。
    -   *基础信息*：`课程时长`。

### 4. 场景示例
> **场景**：L3等级用户，单课模式目标增肌，但今天很累（触发降级）。
> - **输入**：等级=L3，推荐降级=True，功能目标="增肌"。
> - **输出**：
>   - `课程难度`: L1 (L3 - 2级)
>   - `课程类型`: 力量
>   - `课程目标`: 增肌 (继承自档案)
>   - `课程时长`: 30 (继承)
>   - `目标部位`: ["全身"] (智能推荐部位)

---

## 节点 3: 环节确认
> 定义：规划课程的时间结构，并加载各环节的基准训练参数。
> > *业务导读*：切分时间蛋糕。把总时长切分为“热身、主训、放松”三块。同时，根据你的等级查阅“配方表”，确定主训要做几组、休息多久、强度多大。

### 1. 输入数据
- **课程元数据** (来源: 节点 2) [通用]：
    -   *推荐标签*：`课程类型`、`课程目标`、`目标部位`、`课程难度`。
    -   *基础信息*：`课程时长`。
- **上下文对象** (来源: 节点 1) [通用]：
    -   `计划上下文` (计划课专用 - 用于匹配环节模板)、`状态数据`。
- **用户档案** (来源: 运动档案)：
    -   *偏好设置*：`运动等级`。
    -   *基础数据*：`性别`。
- **配置表**：
    -   `[1.3 结构与组装配置]`、`[1.1 策略矩阵配置]`、`[1.2 课程环节模板配置]`。

### 2. 处理逻辑
1.  **步骤 1: 时间结构规划**
    > *目的：切分课程总时长，确定各环节的时间预算。*
    -   **切分计算**：依据 `[1.3 结构与组装配置]` 进行切分。
        -   *规则*：`热身动作数` = 向上取整(`课程时长` / 10)。
        -   *规则*：`放松动作数` = 向上取整(`课程时长` / 10)。
        -   *规则*：`热身/放松时长` = `动作数` * 0.5 (min) [固定30s/动作]。
        -   *规则*：`主训时长` = `课程时长` - `热身时长` - `放松时长`。

2.  **步骤 2: 策略参数加载**
    > *目的：确定各环节的训练基调（强度、组数、休息）。*
    -   **遍历环节**：对 `热身`、`主训`、`放松` 分别执行参数加载。
        -   **确定策略键**：根据环节类型确定查表Key。
            -   *规则*：`热身` → Key="激活" (默认) 或 "心肺" (若主训为减脂)。
            -   *规则*：`主训` → **配置上下文映射**：
                -   若 `课程类型` 为强属性 (HIIT/瑜伽/有氧/普拉提/拉伸) → Key=`课程类型`。
                -   若 `课程类型` 为弱属性 (力量/康复) → Key=`课程目标`。
            -   *规则*：`放松` → Key="柔韧" (默认) 或 "恢复"。
        -   **加载基准参数**：查阅 `[1.1 策略矩阵配置]`。
            -   *规则*：获取 `基准组数`, `组间休息`, `负荷策略`, `训练强度`, `循环模式` 等。
        -   **周期化修正**：若存在 `计划上下文.阶段系数`，修正基准参数。
            -   *规则*：`动作组数` = Round(`基准组数` * `阶段系数.容量系数`)。
            -   *规则*：`训练强度` = `基准强度` * `阶段系数.强度系数`。
            -   *注*：此步骤确保“减载期”或“突破期”的宏观策略能落实到单节课的负荷上。

3.  **步骤 3: 训练范式适配**
    > *目的：根据课程类型调整底层逻辑（如瑜伽课不按组数算）。*
    -   **范式映射**：引用 `[1.6 训练范式配置]` 确定范式。
        -   *规则*：根据 `课程类型` 映射 `训练范式`。
    -   **参数覆盖**：根据范式调整默认参数。
        -   *规则*：**抗阻范式** (主训)：沿用基准参数。
        -   *规则*：**间歇范式** (HIIT)：强制 `循环模式`="循环组", `负荷策略`="计时", `休息配置`=True。
        -   *规则*：**流式范式** (瑜伽)：强制 `动作组数`=1, `休息配置`=False, `负荷策略`="计时"。
    -   **等级适配 (Level Adaptation)** [新增]：
        -   *目的*：基于运动科学，差异化调整不同等级用户的训练变量。
        -   *规则*：
            -   `动作组数` = Round(`基准组数` * `[1.4 等级配置].容量系数`)。
            -   `训练强度` = `基准强度` * `[1.4 等级配置].强度系数`。
            -   `组间休息` = `基准休息` * `[1.4 等级配置].间歇系数`。

4.  **步骤 4: 容量规划计算**
    > *目的：基于时长和范式快速估算动作容量。*
    -   **定义单动作耗时 (Unit Cost)**：
        -   **抗阻范式**：`UnitCost` = `组数` * (0.75 + `组间休息`/60)  *(0.75min ≈ 45s执行)*
        -   **间歇范式**：`UnitCost` = `组数` * (1.0 + `组间休息`/60)   *(1.0min ≈ 60s执行)*
        -   **流式范式**：`UnitCost` = 1.0                            *(1.0min/体式)*
    -   **计算数量**：
        -   `目标数量` = 向下取整(`环节时长` / `UnitCost`)
    -   **兜底修正**：
        -   `目标数量` = Max(1, Min(`目标数量`, `配置.动作数量限制`))

5.  **步骤 5: 动作槽位确认 (Slot Instantiation)**
    > *目的：基于模板生成具体的“待填坑位”。*
    -   **模板加载**：匹配 `[1.2 课程环节模板]`。
        -   *规则*：基于 `部位`、`目标`、`等级` 找到最佳模板。
    -   **槽位展开**：将 `目标数量` 按模板比例分配给各槽位。
        -   *示例*：目标5个动作，模板配比(胸中束0.4:胸上束0.4:三头0.2)。
        -   *结果*：`待填列表` = [胸中束, 胸中束, 胸上束, 胸上束, 三头肌]。
    -   **排序策略加载**：获取模板定义的 `排序规则` (如：主动肌 > 动作构造)。

### 3. 输出数据
- **环节列表** (流转至: 节点 4)：
    -   *基础信息*：`环节类型`。
    -   *训练配置*：`时长`、`组数`、`强度`、`休息`、`策略`。
    -   *结构配置*：`待填槽位列表` (含具体的筛选条件)、`排序策略`。

---

## 节点 4: 动作确认
> 定义：漏斗式筛选模型 (剔除 -> 粗选 -> 打分 -> 填充 -> 排序)。
> > *业务导读*：先用大网捞鱼（粗选），再按喜好挑鱼（打分），最后按萝卜坑填鱼（槽位填充）。

### 1. 输入数据
- **环节列表** (来源: 节点 3)：
    -   `待填槽位列表`、`排序策略`。
- **上下文对象** (来源: 节点 1)：
    -   `可用器械`、`禁忌部位`、`推荐降级`。
- **动作库** (来源: 数据库)。
- **配置表**：
    -   `[3.1 推荐影响因子配置]`、`[2.2 难度兼容策略配置]`。

### 2. 处理逻辑
1.  **步骤 1: 动作剔除 (Exclusion)**
    > *目的：安全风控，一票否决。*
    -   **规则**：
        -   `没有的配件`：`动作.器械` ⊈ `用户.可用器械`。
        -   `疼痛部位`：`动作.疼痛` ∩ `用户.疼痛` ≠ Ø。
        -   `冲击等级`：`动作.冲击`="高" && (`BMI`>28 或 `部位`∈[膝,踝])。

2.  **步骤 2: 动作粗选 (Rough Selection)**
    > *目的：根据课程大方向，圈定候选池。*
    -   **规则**：
        -   `主要目标`：`动作.类型` 匹配 `课程.类型` (如 力量课选力量动作)。
        -   `功能目标`：`动作.功能` 包含 `课程.目标` (如 增肌)。
        -   `训练部位`：`动作.部位` 匹配 `课程.部位` (仅针对分化训练，全身/HIIT跳过此步)。
    -   **产出**：`候选动作池`。

3.  **步骤 3: 动作打分 (Scoring)**
    > *目的：计算推荐优先级。*
    -   **基础分**：100分。
    -   **奖励项**：
        -   `喜欢奖励` (+30)：用户收藏。
        -   `新鲜奖励` (+20)：7天内未练。
        -   `探索奖励` (+10)：从未练过。
    -   **惩罚项**：
        -   `不喜欢惩罚` (-50)：用户移除过。
        -   `厌倦惩罚` (-80)：连续3次出现。
        -   `冷宫惩罚` (-100)：30天内被手动替换过。
    -   **产出**：带分数的候选池。

4.  **步骤 4: 槽位填充 (Slot Filling)**
    > *目的：萝卜坑匹配。*
    -   **遍历**：依次处理 `待填槽位列表` 中的每个槽位。
    -   **匹配**：从候选池中选出 `分数最高` 且 `符合槽位要求` (如: 主动肌=三角肌中束) 的动作。
    -   **候补**：若无精准匹配，放宽槽位条件 (如: 三角肌中束 -> 三角肌 -> 肩部) 再次匹配。
    -   **去重**：选中后从候选池移除，避免重复。

5.  **步骤 5: 动作排序 (Sorting)**
    > *目的：调整执行顺序。*
    -   **规则**：基于 `环节模板.排序策略` 对已选动作进行重排。
    -   *示例*：`主动肌` (大->小) > `动作构造` (复合->孤立) > `器械` (聚合)。

### 3. 输出数据
- **填充后的环节列表** (流转至: 节点 5)：
    -   *动作配置*：`动作序列` (含ID及基础属性)。

### 4. 场景示例
> **场景**：填充“复合推类”槽位，用户有哑铃。
> - **输入**：槽位=复合推类，安全池包含[杠铃卧推, 哑铃卧推, 俯卧撑]，用户器械=[哑铃]。
> - **过程**：
>   - 杠铃卧推 → 剔除 (没杠铃)。
>   - 哑铃卧推 → +100分 (匹配), +60分 (新鲜)。
>   - 俯卧撑 → +100分 (匹配), -80分 (刚练过)。
> - **输出**：选中 [哑铃卧推]。

---

## 节点 5: 动作实例化
> 定义：计算每个动作的具体执行参数（重量/次数/组数）。
> > *业务导读*：精算负荷。给选出来的动作算具体的重量和次数。如果是新动作，就根据你的测评数据推算；如果是老动作，就根据历史记录调整。还会安排每一组的变化，比如第一组轻点，第二组重点。

### 1. 输入数据
- **动作序列** (来源: 节点 4)。
- **基准参数** (来源: 节点 3)：
    -   `训练强度`、`负荷策略`、`动作组数`。
- **用户档案** (来源: 运动档案)：
    -   *能力数据*：`1RM记录`、`部位测评1RM`。
- **逻辑库**：`[重量推荐逻辑]`。
- **配置表**：`[2.1 负荷与组间策略配置]`、`[重量推荐逻辑.md] - [3.1 RM与百分比换算表]`、`[数据映射.md] - [4. 强度指标换算映射]`。

### 2. 处理逻辑
1.  **步骤 1: 计算模式判定**
    > *目的：决定算法是优先算重量还是优先算次数。*
    -   **判定逻辑**：确定计算优先级。
        -   *规则*：若 `训练范式` == "抗阻范式" && `动作.默认交互` != "计时" → **负荷优先模式**。
        -   *规则*：否则 (间歇/流式范式 或 计时动作) → **容量优先模式**。

2.  **步骤 2: 基准参数计算**
    > *目的：计算动作的标准负荷锚点（即“100%强度”时的参数）。*
    -   **若为 [负荷优先模式]**：
        -   **定重量**：计算基准重量。
            -   *规则*：调用 `[重量推荐逻辑]` (输入: `1RM记录` || `测评数据`, `环节.训练强度`) → `基准重量`。
        -   **定次数**：计算理论最大次数。
            -   *规则*：查阅 `[3.1 RM与百分比换算表]` (输入: `环节.训练强度`) → `理论最大次数`。
        -   **RPE修正**：基于RPE调整次数。
            -   *规则*：`基准次数` = Max(1, `理论最大次数` - (10 - `环节.目标RPE`))。
            -   *注*：RPE 8 代表保留 2 次 (10-8)，即做 10RM 的重量只做 8 个。
    -   **若为 [容量优先模式]**：
        -   **定容量**：计算基准容量。
            -   *规则*：查阅 `[4. 强度指标换算映射]` (输入: `环节.训练强度`) → `基准时长` (计时) || `基准次数` (计次)。
        -   **定重量**：适配力量模组重量。
            -   *规则*：若 `动作.力量模组` == "是" → 调用 `[重量推荐逻辑]` (基于时长适配)；否则 `基准重量` = 0。

3.  **步骤 3: 组间策略序列生成**
    > *目的：生成每一组的具体参数（第一组轻，第二组重...）。*
    -   **应用策略**：加载组间变化策略。
        -   *规则*：引用 `[2.1 负荷与组间策略配置]` (依据: `环节.负荷策略`)。
    -   **序列展开**：生成每组具体参数。
        -   *规则*：遍历 `环节.动作组数`，对每一组应用 `负荷系数` 和 `次数增量`。
        -   *规则*：`当前组重量` = `基准重量` * `负荷系数`。
        -   *规则*：`当前组次数` = `基准次数` + `次数增量` (或 `当前组时长` = `基准时长` * `负荷系数`)。
        -   *规则*：`当前组休息` = `环节.组间休息`。

4.  **步骤 4: 执行时长估算**
    > *目的：计算动作的总耗时，用于课程总时长统计。*
    -   **单次耗时**：计算单次动作时间。
        -   *规则*：若 `环节.动作节奏` (如 "2-0-2-0") 存在 → `单次耗时` = Sum(节奏) (4s)。
        -   *规则*：否则 → `单次耗时` = `动作.单次动作时长`。
    -   **单组执行时长**：计算单组净运动时间。
        -   *规则*：计次：`执行时长` = `当前组次数` * `单次耗时`。
        -   *规则*：计时：`执行时长` = `当前组时长`。
    -   **单边修正**：处理单边动作时长。
        -   *规则*：若 `动作.单边独立性` == True → `执行时长` = `执行时长` * 2 + 5s (换边缓冲)。
    -   **总耗时**：汇总课程总时长。
        -   *规则*：Sum(`每组执行时长` + `每组休息时间`)。

### 3. 输出数据
- **实例化课程** (流转至: 节点 6)：
    -   *动作配置*：`实例化动作列表` (含组序列: 重量/次数/时长/休息/单组耗时)。

### 4. 场景示例
> **场景**：计算“哑铃卧推”的参数，用户1RM=20kg，强度=75%，策略=递增。
> - **输入**：1RM=20kg, 强度=0.75 (基准重量15kg), 策略=递增 (系数: 0.85/0.90/1.0), 基准次数=10。
> - **输出**：
>   - 第1组: 12.5kg (15*0.85), 12次 (10+2)
>   - 第2组: 13.5kg (15*0.90), 11次 (10+1)
>   - 第3组: 15.0kg (15*1.00), 10次 (10+0)

---

## 节点 6: 用户微调
> 定义：响应用户在前端的主动修改请求，实时重算课程参数。
> > *业务导读*：最后的把关。把生成好的课程展示给用户，用户如果不喜欢某个动作可以换，觉得太难可以调。系统根据用户的修改指令，实时重新计算参数。

### 1. 输入数据
- **实例化课程** (来源: 节点 5)。
- **用户指令** (来源: 前端交互)：
    -   **结构指令**：`重置生成` (修改输入)、`环节增减` (如删除热身)、`动作排序`、`动作删除`。
    -   **内容指令**：`动作替换`、`器械切换` (如哑铃换杠铃)。
    -   **参数指令**：`修改负荷` (重量/次数/组数/时长)、`修改策略` (负荷策略/循环模式)、`全局难度`。

### 2. 处理逻辑
1.  **步骤 1: 全局重构处理**
    > *目的：响应影响课程整体结构的重大修改。*
    -   **重置生成**：响应核心参数变更。
        -   *规则*：若用户修改 `目标部位` / `课程时长` / `课程类型` → 携带新参数重新调用 `[节点 2: 课程确认]` 及后续流程 (State Re-entry)。
    -   **环节增减**：响应环节的增删操作。
        -   *规则*：若 `删除环节` (如不要热身) → 该环节 `目标动作数` 置 0，时长释放。
        -   *规则*：若 `增加环节` → 调用 `[节点 3: 环节确认]` 获取默认参数。
        -   **时长平衡策略**：决定释放时长的去向。
            -   *规则*：释放的时长可选择 `填充至主训` 或 `缩短总课时` (默认缩短)。

2.  **步骤 2: 动作筛选微调**
    > *目的：在不改变结构的前提下，调整具体的动作内容。*
    -   **动作替换**：重新筛选并替换指定动作。
        -   *规则*：将 `目标动作ID` 加入 `黑名单`。
        -   *规则*：调用 `[节点 4: 动作确认]` (输入: 黑名单, 原槽位) → 获取 `新候选动作`。
        -   *规则*：调用 `[节点 5: 动作实例化]` → 生成实例并替换。
    -   **动作删除**：移除动作并更新时长。
        -   *规则*：直接从序列移除，并更新 `课程总时长`。
    -   **器械切换**：基于器械变更触发动作替换。
        -   *规则*：用户指定某动作 `更换器械` (如: 哑铃 -> 徒手)。
        -   *规则*：更新 `槽位定义.可用器械` → 触发 `动作替换` 逻辑。

3.  **步骤 3: 策略与参数覆写**
    > *目的：调整训练的“质”与“量”。*
    -   **策略切换联动**：修改环节级负荷策略时的重算逻辑。
        -   **锚点锁定**：获取当前动作所有组中的 `最大负荷` 作为 `目标锚点` (Peak Load)。
        -   **重算规则**：基于 `目标锚点` 应用新策略：
            -   `恒定`：所有组负荷 = `目标锚点`。
            -   `递增`：以 `目标锚点` 为 **末组** 负荷，向前按步进递减。
            -   `递减`：以 `目标锚点` 为 **首组** 负荷，向后按步进递减。
            -   `推荐`：重置为 AI 初始推荐值 (Recommended Set Details)。
    -   **参数手动微调**：响应用户对具体组数据的修改。
        -   **策略自动漂移**：若当前为 `推荐` 策略且用户修改了负荷 → 自动切换为 `递增` 策略 (视为用户意图建立新的进阶基准)。
        -   **线性插值 (Interpolation)**：若策略为 `递增/递减` 且组数 > 2：
            -   *规则*：若用户修改 `首组` 或 `末组` 负荷 → 保持首尾锚点，对中间组进行线性插值重算，确保梯度平滑。
        -   **RM 联动**：
            -   *规则*：若修改 `重量` 且为抗阻范式 → 基于 `1RM` 反推并更新该组的 `建议次数`。
        -   **组数变更**：
            -   *规则*：`增加组` → 复制最后一组的参数；若为梯度策略，尝试维持梯度趋势。
            -   *规则*：`减少组` → 移除最后一组。

4.  **步骤 4: 序列与体验优化**
    > *目的：调整动作的执行顺序。*
    -   **动作排序**：响应拖拽排序指令。
        -   *规则*：响应前端拖拽指令，更新 `动作序列` 索引。
    -   **逻辑校验**：维护组合模式的完整性。
        -   *规则*：若排序导致 `超级组` 被拆散，需弹窗提示或自动解除超级组模式。

5.  **步骤 5: 强度校准**
    > *目的：基于用户主观反馈的整体强度调节。*
    -   **系数修正**：调整全局强度基准。
        -   *规则*：若 "太难" → `全局强度系数` - 0.05 (下限 0.5)。
        -   *规则*：若 "太易" → `全局强度系数` + 0.05 (上限 1.2)。
    -   **批量重算**：刷新非自定义动作的负荷。
        -   *规则*：对 `用户自定义` == False 的动作，调用 `[节点 5: 动作实例化]` 重算负荷。

### 3. 输出数据
- **确认后的课程对象** (流转至: 节点 7)：
    -   *推荐标签*：`课程类型`、`课程目标`、`目标部位`、`课程难度` (含用户修改)。
    -   *基础信息*：`课程时长` (含用户修改)。
    -   *环节配置*：`环节列表` (含用户增删)。
    -   *动作配置*：`实例化动作列表` (含用户自定义参数)。

### 4. 场景示例
> **场景**：用户觉得“哑铃卧推”肩膀不舒服，换成“俯卧撑”。
> - **输入**：指令=替换(哑铃卧推)。
> - **处理**：黑名单=[哑铃卧推]，重跑筛选 → 选中[俯卧撑]。
> - **输出**：更新后的动作列表，其中哑铃卧推变成了俯卧撑。

---

## 节点 7: 最终产出
> 定义：生成最终的课程详情对象，供前端展示和用户执行。
> > *业务导读*：打包出厂。把所有算好的数据整合起来，算出这节课的总卡路里和难度分，生成一句贴心的推荐语，准备上架。

### 1. 输入数据
- **确认后的课程对象** (来源: 节点 6)。
- **用户档案** (来源: 运动档案)：
    -   *基础数据*：`体重` (用于卡路里计算)。

### 2. 处理逻辑
1.  **步骤 1: 基础信息生成**
    > *目的：赋予课程唯一身份标识。*
    -   **ID生成**：创建唯一标识符。
        -   *规则*：生成 `课程ID` (UUID)。
    -   **元数据完善**：补充课程基础信息。
        -   *规则*：确认 `课程名称`、`课程介绍` (若为动态生成)。

2.  **步骤 2: 统计指标计算**
    > *目的：计算课程的能耗与强度指标，供用户参考。*
    -   **课程MET值**：计算平均代谢当量。
        -   *规则*：`Σ(动作.动作MET值 * 动作.总时长) / 课程总时长`。
    -   **预估卡路里**：计算总能量消耗。
        -   *规则*：`运动消耗` = `Σ(动作.动作MET值 * 动作.总时长)`。
        -   *规则*：`休息消耗` = `Σ(1.5 * 休息.总时长)` (假设休息MET=1.5)。
        -   *规则*：`总卡路里` = `(运动消耗 + 休息消耗) * 体重(kg) / 3600` (将秒转换为小时)。

3.  **步骤 3: 展示标签聚合**
    > *目的：提取课程的关键特征标签，用于列表展示和筛选。*
    -   **配件要求**：汇总所需器械。
        -   *规则*：提取并去重所有动作的 `动作器械`。
    -   **疼痛部位**：汇总潜在风险部位。
        -   *规则*：提取并去重所有动作的 `疼痛部位`。
    -   **冲击等级**：判定课程整体冲击性。
        -   *规则*：若包含任意 "高冲击" 动作 → "高冲击"；否则取最高等级。

4.  **步骤 4: 推荐理由生成**
    > *目的：生成一句个性化的推荐文案，告诉用户“为什么推荐这节课”。*
    -   **因子提取**：识别最显著的推荐依据。
        -   *规则*：获取 `动作确认` 阶段触发权值最高的 `推荐因子`。
    -   **文案映射**：生成用户友好的推荐语。
        -   *规则*：基于因子类型映射文案 (如 "新鲜奖励" → "为您精选了近期未练的新动作")。

5.  **步骤 5: 数据装配**
    > *目的：输出符合标准协议的最终数据对象。*
    -   **组装**：整合所有计算结果。
        -   *规则*：将上述计算结果与 `动作列表`、`环节列表` 整合。
    -   **格式化**：标准化输出结构。
        -   *规则*：确保字段类型与《课程属性》定义一致。

### 3. 输出数据
- **完整的课程详情对象** (输出给: 前端/执行端)：
    -   *基础信息*：`课程ID`、`课程名称`、`课程介绍`、`课程形态`。
    -   *推荐标签*：`课程类型`、`课程目标`、`目标部位`、`课程难度`、`课程时长`、`配件要求`、`疼痛部位`、`冲击等级`、`课程MET值`、`预估卡路里`。
    -   *课程素材*：`课程封面图`、`课程缩略图`、`预览视频`、`课程视频`。
    -   *环节配置*：`环节列表`。
    -   *其他*：`推荐理由`。

### 4. 场景示例
> **场景**：生成最终课程详情。
> - **输出**：
>   - **课程信息**：ID=CRS_Gen_001，标题="30分钟胸部增肌"
>   - **统计指标**：卡路里=150kcal，标签=["哑铃", "低冲击"]
>   - **推荐理由**："根据您的恢复状态推荐"

---

## 节点 8: 反馈闭环 (异步处理)
> 定义：课程执行结束后的数据反哺与算法进化。
> > *业务导读*：练完了不是结束，而是下一次更精准推荐的开始。
> *注：本节点逻辑详见《核心逻辑.md》- 第8层及《重量推荐逻辑.md》- 数据更新机制。*

### 1. 输入数据
- **执行数据**：`实际完成组数/重量/次数`、`实际时长`。
- **用户反馈**：`RPE评分`、`动作替换/删除记录`、`课程满意度`。

### 2. 处理逻辑
1.  **能力校准**：更新 `1RM` (基于最大负荷) 和 `记忆重量`。
2.  **偏好学习**：更新 `动作打分权重` (厌恶/收藏)。
3.  **状态更新**：扣除 `部位状态值` (疲劳消耗)。

---

## 需求池
> > *业务导读：未来版本规划的逻辑模块。*
1. **波浪负荷策略**：在平台期干预中引入波浪周期策略。
2. **修正系数逻辑**：基于计划阶段（如减载期）和生理状态（如疲劳/生理期）自动调整强度和容量系数。
3. **生理周期适配**：基于女性生理周期（月经期/卵泡期/排卵期/黄体期）自动调整训练强度、容量及动作禁忌。
4. **睡眠数据适配**：基于昨日睡眠时长修正疲劳恢复速率。
5. **风格策略适配**：基于用户偏好的训练风格（传统/多变/激进）调整课程结构与动作筛选逻辑。
6. **RPE相关逻辑**：基于RPE（自觉费力程度）的强度校准与反馈闭环。
7. **反馈闭环逻辑**：处理训练后的反馈数据（执行数据/替换/收藏），更新用户档案（1RM/偏好/平台期），实现算法进化。
7. **容量规划优化**：引入动态TUT (Time Under Tension) 基准。目前统一按45s估算，需针对力量训练（10-15s）和耐力训练（60s+）进行区分，以提高时长预估准确性。