# 课程生成逻辑
> **文档用途**：本文档是算法落地的“施工图纸”。
> - **产品经理**：请重点关注“业务导读”和“场景示例”，确认逻辑是否符合业务预期。
> - **开发人员**：请重点关注“输入/输出”和“处理逻辑”，这是代码实现的直接依据。
> **设计原则**：高内聚，低耦合。每个节点仅依赖明确的输入，产出标准化的输出。

## 节点流转总览
```mermaid
graph LR
    N1[输入与上下文] --> N2[课程确认]
    N2 --> N3[环节确认]
    N3 --> N4[动作确认]
    N4 --> N5[动作实例化]
    N5 --> N6[用户微调]
    N6 --> N7[数据装配]
    N7 -.-> N8[反馈闭环]
```

---

## 节点 1: 输入与上下文
> 定义：收集并清洗所有影响课程生成的外部变量，构建统一的“约束上下文”。
> > *业务导读*：就像教练在开课前进行的“摸底访谈”。系统需要收集你的基本信息（如身体素质）、当下的需求（想练哪里、练多久）以及限制条件（有没有受伤、有什么器械），把这些信息打包成一个“上下文包”，传给后面的环节。

### 1. 输入数据
- **用户档案**：基础信息(性别/BMI)、能力数据(1RM)、偏好设置(器械/伤病/风格)。
- **场景入口**：
  - *单课模式*：用户实时输入的 `目标部位`、`时长`、`类型`。
  - *计划模式*：上层计划传入的 `计划上下文` (侧重目标/强度系数/环节模板)。
- **状态数据**：`综合疲劳度`、`部位疲劳度`、`生理周期`。

### 2. 处理逻辑
1.  **数据完整性校验**：
    -   检查档案中 `性别`、`BMI`、`运动等级`、`功能目标`、`每日运动时长` 是否存在。
    -   若缺失，中断流程并返回错误码，引导用户补全档案。
2.  **疲劳风控推荐**：
    -   读取 `综合疲劳度` 数据。
    -   **判断**：若 `综合疲劳度` < 55 (全身疲劳/力竭)。
    -   **执行**：标记 `推荐降级` (难度 -2)。
3.  **上下文合并与优先级仲裁**：
    -   **目标部位**：`用户输入` > `智能推荐` (基于 `部位疲劳度` 筛选 `已恢复` 部位) > `计划上下文`。
    -   **时长预算**：`用户输入` > `档案.每日运动时长` > `计划上下文`。
    -   **器械列表**：`全量器械库` - `档案.没有的器械`。
    -   **禁忌部位**：`档案.疼痛部位` ∪ `疲劳度.力竭部位`。

### 3. 输出数据
- **约束对象**：
    -   `有效目标部位` (列表)
    -   `时间预算` (整数，分钟)
    -   `可用器械` (列表)
    -   `禁忌部位` (列表，含伤病与严重疲劳)
    -   `强制降级` (布尔值)
    -   `状态数据` (生理周期/疲劳度)
    -   `计划上下文` (若有)

### 4. 场景示例 
> **场景**：一个膝盖有伤的用户，想练胸，只有哑铃。
> - **输入**：目标="胸部"，档案疼痛="膝盖"，档案器械="哑铃"。
> - **输出**：
>   - `有效目标部位`: ["胸部"]
>   - `时间预算`: 30 (默认)
>   - `可用器械`: ["哑铃", "自重"]
>   - `禁忌部位`: ["膝盖"] (后续会剔除深蹲等动作)
>   - `推荐降级`: False
>   - `状态数据`: 正常

---

## 节点 2: 课程确认
> 定义：确定课程的宏观元数据，为后续环节定调。
> > *业务导读*：给这节课定调。确定主题是“增肌”还是“减脂”，难度是“入门”还是“专业”。这一步相当于教练在教案本上写下课程标题和摘要。

### 1. 输入数据
- **约束对象** (来自 节点 1)
- **用户档案** (`运动等级`, `功能目标`)

### 2. 处理逻辑
1.  **目标定性**：
    -   **判断**：若 `约束对象` 包含 `计划.侧重目标` → 直接继承。
    -   **否则**：使用 `档案.功能目标`。
2.  **难度定级**：
    -   **基准**：读取 `档案.运动等级`。
    -   **修正**：若 `推荐降级` == true → `课程难度` = 最大值(L1, 基准难度 - 2)。
3.  **类型映射**：
    -   **逻辑**：若 `输入类型` 为空 → 基于 `课程目标` 映射。
    -   **映射表**：
        -   增肌/力量/塑形 -> **力量**
        -   减脂/心肺/耐力 -> **HIIT** (或有氧)
        -   恢复/柔韧/体态 -> **拉伸** (或瑜伽)
4.  **部位解析**：
    -   若输入 == "动作模式" → 查阅《数据映射表》 → 转换为 `解剖部位`。

### 3. 输出数据
- **课程元数据**：
    -   `课程目标` (枚举)
    -   `课程难度` (枚举)
    -   `课程类型` (枚举)
    -   `课程时长` (整数)
    -   `目标部位` (列表)

### 4. 场景示例 
> **场景**：L3等级用户，目标增肌，但今天很累（触发降级）。
> - **输入**：等级=L3，强制降级=True，目标=增肌。
> - **输出**：
>   - `课程难度`: L1 (L3 - 2级)
>   - `课程类型`: 力量
>   - `课程目标`: 增肌
>   - `课程时长`: 30 (继承)
>   - `目标部位`: ["胸部"] (继承)

---

## 节点 3: 环节确认
> 定义：切分时间片，并加载每个时间片的基准训练参数（配方）。
> > *业务导读*：切分时间蛋糕。把总时长切分为“热身、主训、放松”三块。同时，根据你的等级查阅“配方表”，确定主训要做几组、休息多久、强度多大。

### 1. 输入数据
- **课程元数据** (来自 节点 2)
- **约束对象** (来自 节点 1)
- **配置表**：`[1.3 结构配置]`, `[1.1 策略矩阵]`, `[1.2 环节模板]`

### 2. 处理逻辑
1.  **时间切分**：
    -   读取 `[1.3 结构配置]` (`推荐占比`, `最大时长`).
    -   **热身/放松时长** = 最小值(`课程时长` * `推荐占比`, `最大时长`)。
    -   **主训时长** = `课程时长` - `热身时长` - `放松时长`。
2.  **参数加载 (查表)**：
    -   **键**：`课程目标` + `课程难度`。
    -   **表**：`[1.1 策略矩阵]`。
    -   **值**：`基准组数`, `基准强度`, `目标RPE`, `休息配置`, `负荷策略`。
3.  **模板匹配 (主训)**：
    -   **键**：`目标部位` + `运动等级` + `性别`。
    -   **表**：`[1.2 环节模板]`。
    -   **匹配逻辑**：`部位_等级_性别` (精确) > `部位_等级` (降级) > `部位` (通用)。
    -   **产出**：`槽位定义列表`。
4.  **系数计算**：
    -   **计划系数**：取自 `约束对象.计划上下文` (若无则 1.0)。
    -   **状态系数**：基于 `约束对象.状态数据` (生理/疲劳) → 查阅 `[4.1 状态适配配置]`。
    -   **合并**：`修正系数` = `计划系数` * `状态系数`。
5.  **参数修正**：
    -   **执行**：
        -   `最终强度` = `基准强度` * `修正系数.强度`。
        -   `最终组数` = 最大值(1, 四舍五入(`基准组数` * `修正系数.容量`))。

### 3. 输出数据
- **环节列表 (列表<环节对象>)**，每个环节包含：
    -   `环节类型` (热身/主训...)
    -   `环节时长`
    -   `基准参数` (强度/组数/RPE...)
    -   `槽位定义` (列表<槽位>) [仅主训环节]

### 4. 场景示例 
> **场景**：30分钟胸部训练，L3等级。
> - **输入**：时长=30min，部位=胸部，等级=L3。
> - **输出**：
>   - `热身环节`: 4分钟
>   - `主训环节`: 22分钟
>     - `基准参数`: 4组, 强度75%, 组间休90s
>     - `槽位`: [复合推类(60%), 孤立夹类(40%)]
>   - `放松环节`: 4分钟

---

## 节点 4: 动作确认
> 定义：从动作库中筛选最佳动作，填充到规划好的槽位中。
> > *业务导读*：选品上架。从动作库里挑选动作填入槽位。第一步是“安检”，剔除受伤不能做、没器械做不了的动作；第二步是“选秀”，按新鲜感、匹配度给动作打分，分高的入选。

### 1. 输入数据
- **环节列表** (来自 节点 3)
- **约束对象** (伤病/器械，来自 节点 1)
- **动作库** (全量数据)
- **配置表**：`[3.1 推荐因子]`

### 2. 处理逻辑
1.  **全局清洗 (白名单构建)**：
    -   **伤病过滤**：剔除 (`动作.疼痛部位` ∩ `约束对象.禁忌部位` ≠ Ø)。
    -   **器械过滤**：剔除 (`动作.动作器械` ⊄ `约束对象.可用器械`)。
    -   **产出**：`安全动作池`。
2.  **环节填充循环**：
    -   **热身/放松环节**：
        -   **筛选**：`安全池` ∋ (`动作.动作功能` ⊆ `环节类型定义`)。
        -   **关联**：优先 `动作.关联部位` ≈ `主训.目标部位`。
        -   **数量控制**：Min(`环节时长` / 30s, `[1.3].动作数量限制`)。
    -   **主训环节**：
        -   **容量计算**：
            -   `预估总动作数` = `环节时长` / (`平均单组耗时` + `平均组间休`)。
            -   `槽位动作数(N)` = Ceil(`预估总动作数` * `槽位占比`)。
        -   **遍历槽位**：对每个槽位（如“复合动作槽位”）：
            -   **初筛 (概率难度匹配)**：
                -   读取 `[2.2 难度兼容策略]` (概率分布)。
                -   生成 `目标难度` (基于概率)。
                -   筛选：`安全池` ∋ (`动作.难度` == `目标难度` && `动作` ⊆ `槽位定义`)。
                -   *注*：若无结果 → 回退至 `运动等级` (L0)。
            -   **打分**：`总分` = Σ(推荐因子权重)。
                -   *新鲜奖励*：`上次训练 > 7天` → +60分。
                -   *匹配奖励*：`完全符合骨架` → +100分。
                -   *一致性奖励*：`在计划中` && `上次训练 包含 动作` → +80分。
                -   *厌倦惩罚*：`连续使用次数 >= 3` → -80分。
            -   **截取**：排序(`分数`, 降序) → 截取 `Top N`。
            -   **兜底**：若 `数量(候选动作) < N`，依次降级：
                1.  **降难度**：`动作难度` ∈ [L1, L4]。
                2.  **扩范围**：`槽位定义` 扩大 (e.g. "水平推" → "上肢推")。
                3.  **改性质**：`功能过滤` 放宽 (e.g. "增肌" → "耐力")。
                4.  **保骨架**：仅匹配 `目标部位`。
3.  **排序优化**：
    -   **能量管理**：排序(`动作.构造`, 复合 > 孤立)。
    -   **减少切换**：分组(`动作.器械`, `动作.体位`)。
    -   **超级组配对**：若 `循环模式` == "超级组" → 配对(`主动肌`, `拮抗肌`)。
    -   **安全风控**：若 `连续高冲击动作` > 2 → 推荐插入 `低冲击动作`。

### 3. 输出数据
- **填充后的环节列表**：
    -   每个环节下新增 `动作序列 (列表<动作实例>)`。
    -   动作仅包含 ID 和基础属性，尚未计算重量次数。

### 4. 场景示例 
> **场景**：填充“复合推类”槽位，用户有哑铃。
> - **输入**：槽位=复合推类，安全池包含[杠铃卧推, 哑铃卧推, 俯卧撑]。
> - **过程**：
>   - 杠铃卧推 -> 剔除 (没杠铃)。
>   - 哑铃卧推 -> +100分 (匹配), +60分 (新鲜)。
>   - 俯卧撑 -> +100分 (匹配), -80分 (刚练过)。
> - **输出**：选中 [哑铃卧推]。

---

## 节点 5: 动作实例化
> 定义：原子化计算每个动作的具体负荷（重量/次数/组数）。
> > *业务导读*：精算负荷。给选出来的动作算具体的重量和次数。如果是新动作，就根据你的测评数据推算；如果是老动作，就根据历史记录调整。还会安排每一组的变化，比如第一组轻点，第二组重点。

### 1. 输入数据
- **动作序列** (来自 节点 4)
- **用户能力** (`1RM`, `测评数据`)
- **基准参数** (强度/RPE/负荷策略，来自 节点 3)
- **逻辑库**：`[重量推荐逻辑]`

### 2. 处理逻辑
1.  **模式判定**：
    -   **判断**：检查 `动作.默认计量维度` & `环节.负荷策略`。
    -   **分支**：
        -   **负荷优先** (力量/增肌)：`重量` → `次数`。
        -   **容量优先** (有氧/HIIT)：`时长/次数` → `重量`。
2.  **参数计算**：
    -   **分支 A：负荷优先模式**（适用于力量/增肌/塑形）：
        -   **定重量**：调用 `[重量推荐逻辑]`。
            -   有历史：`1RM` * `基准强度` * `遗忘曲线系数`。
            -   无历史：`测评1RM` * `肌肉系数` * `基准强度`。
        -   **定次数**：`理论最大次数` = 查表(`RM表`, `基准强度`)；`推荐次数` = `理论最大次数` - (10 - `目标RPE`)。
        -   **定组数**：`组数` = `环节.动作组数`。
    -   **分支 B：容量优先模式**（适用于有氧/HIIT/自重/功能）：
        -   **定容量**：
            -   计时类：`推荐时长` = 查表(`强度表`, `基准强度`)；`次数` = 0。
            -   计次类：`推荐次数` = 查表(`强度表`, `基准强度`)；`时长` = 0。
        -   **定重量**：
            -   无电机：`重量` = 0。
            -   有电机：调用 `[重量推荐逻辑].基于时长负荷推荐`。
        -   **定组数**：`组数` = `环节.动作组数`。
3.  **序列生成**：
    -   **应用策略**：应用 `负荷策略` (如 "正金字塔") → 生成 `组序列`。
    -   **示例**：
        -   第1组：重量 85%，次数 +2。
        -   第2组：重量 90%，次数 +1。
        -   第3组：重量 100%，次数 +0。
4.  **时长估算**：
    -   `单组耗时` = (`推荐次数` * `动作.单次动作时长` [默认: 3s]) + `组间休息`。
    -   `实际环节时长` = Σ(`单组耗时`)。

### 3. 输出数据
- **实例化动作列表**：
    -   包含完整的 `组序列 (列表<组>)`。
    -   每组包含：`重量`, `次数`, `时长`, `休息时间`。

### 4. 场景示例 
> **场景**：计算“哑铃卧推”的参数，用户1RM=20kg，强度=75%，策略=递增。
> - **输入**：1RM=20kg, 强度=0.75, 策略=递增。
> - **输出**：
>   - 第1组: 12.5kg (20*0.75*0.85), 12次
>   - 第2组: 13.5kg (20*0.75*0.90), 11次
>   - 第3组: 15.0kg (20*0.75*1.00), 10次

---

## 节点 6: 用户微调
> 定义：处理用户在前端的主动修改请求。
> > *业务导读*：最后的把关。把生成好的课程展示给用户，用户如果不喜欢某个动作可以换，觉得太难可以调。系统根据用户的修改指令，实时重新计算参数。

### 1. 输入数据
- **实例化课程** (来自 节点 5)
- **用户指令** (替换动作 / 修改参数 / 调整难度)

### 2. 处理逻辑
1.  **动作替换**：
    -   **输入**：`目标动作ID`。
    -   **重筛选**：`黑名单` += `目标动作ID`；重跑 `节点 4`；截取 `前2项`。
    -   **重计算**：重跑 `节点 5` (对象: `新动作`)。
2.  **参数修改**：
    -   **输入**：`组.重量` || `组.次数`。
    -   **执行**：覆盖 `组` 数值。
    -   **标记**：`动作.标签` += "用户自定义"。
3.  **难度调整**：
    -   **输入**：`难度调整` (+/-)。
    -   **执行**：`全局强度系数` += (±0.05)。
    -   **重计算**：重跑 `节点 5` (对象: 所有动作)。

### 3. 输出数据
- **用户确认后的课程对象**。

### 4. 场景示例 
> **场景**：用户觉得“哑铃卧推”肩膀不舒服，换成“俯卧撑”。
> - **输入**：指令=替换(哑铃卧推)。
> - **处理**：黑名单=[哑铃卧推]，重跑筛选 -> 选中[俯卧撑]。
> - **输出**：更新后的动作列表，其中哑铃卧推变成了俯卧撑。

---

## 节点 7: 最终产出
> 定义：生成最终的课程详情信息，供前端展示和用户执行。
> > *业务导读*：打包出厂。把所有算好的数据整合起来，算出这节课的总卡路里和难度分，生成一句贴心的推荐语，准备上架。

### 1. 输入数据
- **确认后的课程对象** (来自 节点 6)

### 2. 处理逻辑
1.  **元数据生成**：
    -   生成 `课程ID`。
    -   **推荐理由**：基于 `最大值(推荐因子)` → 生成文案。
2.  **统计计算**：
    -   `预估卡路里` = Σ(`动作.动作MET值` * `动作.时长` * `体重系数`)。
    -   `预估RPE` = Σ(`环节.目标RPE` * `环节.环节时长`) / `课程.课程时长`。
3.  **标签聚合**：
    -   聚合 `配件要求` & `疼痛部位` & `冲击等级` (来源: `动作列表`)。

### 3. 输出数据
- **完整的课程详情对象** (符合《课程属性》定义)。

### 4. 场景示例 
> **场景**：生成最终课程详情。
> - **输出**：
>   - **课程信息**：ID=CRS_Gen_001，标题="30分钟胸部增肌"
>   - **统计指标**：卡路里=150kcal，标签=["哑铃", "低冲击"]
>   - **推荐理由**："根据您的恢复状态推荐"

---

## 节点 8: 反馈闭环
> 定义：课程执行后的数据闭环，不参与生成，但影响下一次生成。
> > *业务导读*：课后复盘。练完之后，系统会根据你反馈的“累不累”（RPE）来调整你的能力值，根据你“换动作”的行为来调整你的偏好。越练越懂你。

### 1. 输入数据
- **执行数据** (实际完成的重量/次数)
- **用户反馈** (课后RPE, 替换行为, 收藏行为)

### 2. 处理逻辑
1.  **能力校准**：
    -   **RPE 校验**：若 |`用户.反馈RPE` - `预估RPE`| > 2：
        -   `反馈RPE` > `预估RPE` → 下调 `档案.1RM` (如 -5%)。
        -   `反馈RPE` < `预估RPE` → 上调 `档案.1RM` (如 +5%)。
    -   **1RM 自动更新**：若 `实际重量` > `当前1RM` → 更新 `档案.1RM`。
2.  **偏好学习**：
    -   **冷宫逻辑**：若 `动作.替换次数` > 3 → `冷宫池` += `动作` (Score -= 50)。
    -   **加分逻辑**：若 `动作.收藏` == true → `加分池` += `动作` (Score += 50)。
3.  **平台期识别**：
    -   **判断**：若 `Consecutive(NoWeightIncrease)` >= 5。
    -   **标记**：`部位.Status` = "平台期"。
    -   **影响**：NextGen `Node 3` → Recommend `负荷策略` = "递减"。

### 3. 输出数据
- **更新后的用户档案**。

### 4. 场景示例 
> **场景**：用户反馈RPE=9（太累），预估RPE=7。
> - **输入**：反馈RPE=9, 预估RPE=7。
> - **处理**：偏差=2，触发下调逻辑。
> - **输出**：更新档案，胸部强度系数 1.0 -> 0.95。

## 需求池
> > *业务导读：未来版本规划的逻辑模块。*
1. **波浪负荷策略**：在平台期干预中引入波浪周期策略。