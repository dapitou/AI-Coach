# 课程生成逻辑
> **文档用途**：本文档是算法落地的“施工图纸”。
> - **产品经理**：请重点关注“业务导读”和“场景示例”，确认逻辑是否符合业务预期。
> - **开发人员**：请重点关注“输入/输出”和“处理逻辑”，这是代码实现的直接依据。
> **设计原则**：高内聚，低耦合。每个节点仅依赖明确的输入，产出标准化的输出。

## 节点流转总览
```mermaid
graph LR
    N1[输入与上下文] --> N2[课程确认]
    N2 --> N3[环节确认]
    N3 --> N4[动作确认]
    N4 --> N5[动作实例化]
    N5 --> N6[用户微调]
    N6 --> N7[数据装配]
    N7 -.-> N8[反馈闭环]
```

---

## 节点 1: 输入与上下文
> 定义：收集并清洗所有影响课程生成的外部变量，构建统一的“约束上下文”。
> > *业务导读*：就像教练在开课前进行的“摸底访谈”。系统需要收集你的基本信息（如身体素质）、当下的需求（想练哪里、练多久）以及限制条件（有没有受伤、有什么器械），把这些信息打包成一个“上下文包”，传给后面的环节。

### 1. 输入数据
- **用户档案**：基础信息(性别/BMI)、能力数据(1RM)、偏好设置(器械/伤病/风格)。
- **场景入口**：
  - *单课模式*：用户实时输入的 `目标部位`、`时长`、`类型`。
  - *计划模式*：上层计划传入的 `计划上下文` (侧重目标/强度系数/环节模板)。
- **状态数据**：`部位疲劳度`、`生理周期`。

### 2. 处理逻辑
1.  **数据完整性校验**：
    -   检查档案中 `性别`、`BMI`、`运动等级` 是否存在。
    -   若缺失，中断流程并返回错误码，引导用户补全档案。
2.  **疲劳风控拦截**：
    -   读取 `部位疲劳度` 数据。
    -   **判断**：若用户选择的 `目标部位` 状态为“力竭”或“疲劳中”（状态值 < 55）。
    -   **执行**：
        -   若用户坚持训练，标记 `强制降级` 信号（后续难度计算时强制 -2 级）。
        -   若为计划生成模式，尝试自动切换为“主动恢复”课程。
3.  **上下文合并与优先级仲裁**：
    -   **目标部位**：计划上下文指定 > 用户实时输入 > 档案推荐。
    -   **时长预算**：计划上下文指定 > 用户实时输入 > 档案每日习惯时长。
    -   **器械列表**：取档案中的 `可用器械`（排除用户标记为“没有”的器械）。
    -   **禁忌部位**：合并档案中的 `疼痛部位` 和 疲劳度中的 `力竭部位`。

### 3. 输出数据
- **约束对象**：
    -   `有效目标部位` (列表)
    -   `时间预算` (整数，分钟)
    -   `可用器械` (列表)
    -   `禁忌部位` (列表，含伤病与严重疲劳)
    -   `修正系数` (强度/容量系数)
    -   `强制降级` (布尔值)

### 4. 场景示例 
> **场景**：一个膝盖有伤的用户，想练胸，只有哑铃。
> - **输入**：目标="胸部"，档案疼痛="膝盖"，档案器械="哑铃"。
> - **输出**：
>   - `有效目标部位`: ["胸部"]
>   - `可用器械`: ["哑铃", "自重"]
>   - `禁忌部位`: ["膝盖"] (后续会剔除深蹲等动作)

---

## 节点 2: 课程确认
> 定义：确定课程的宏观元数据，为后续环节定调。
> > *业务导读*：给这节课定调。确定主题是“增肌”还是“减脂”，难度是“入门”还是“专业”。这一步相当于教练在教案本上写下课程标题和摘要。

### 1. 输入数据
- **约束对象** (来自 节点 1)
- **用户档案** (`运动等级`, `功能目标`)

### 2. 处理逻辑
1.  **目标定性**：
    -   **判断**：若 `约束对象` 中包含计划传入的 `侧重目标`，则直接继承。
    -   **否则**：使用用户档案中的 `功能目标`（如“增肌”）。
2.  **难度定级**：
    -   **基准**：读取档案 `运动等级` (如 L3)。
    -   **修正**：若 `强制降级` 为真，则 `课程难度` = Max(L1, 基准难度 - 2)。
3.  **类型映射**：
    -   根据 `课程目标` 映射 `课程类型`。
    -   例如：目标="增肌" -> 类型="力量"；目标="减脂" -> 类型="HIIT"。
4.  **部位解析**：
    -   若输入的是“动作模式”（如“水平推”），需查阅《数据映射表》将其转换为解剖部位（如“胸部”+“肩部”+“肱三头肌”）。

### 3. 输出数据
- **课程元数据**：
    -   `课程目标` (枚举)
    -   `课程难度` (枚举)
    -   `课程类型` (枚举)
    -   `总时长` (整数)
    -   `目标部位` (列表)

### 4. 场景示例 
> **场景**：L3等级用户，目标增肌，但今天很累（触发降级）。
> - **输入**：等级=L3，强制降级=True，目标=增肌。
> - **输出**：
>   - `课程难度`: L1 (L3 - 2级)
>   - `课程类型`: 力量
>   - `课程目标`: 增肌

---

## 节点 3: 环节确认
> 定义：切分时间片，并加载每个时间片的基准训练参数（配方）。
> > *业务导读*：切分时间蛋糕。把总时长切分为“热身、主训、放松”三块。同时，根据你的等级查阅“配方表”，确定主训要做几组、休息多久、强度多大。

### 1. 输入数据
- **课程元数据** (来自 节点 2)
- **配置表**：`[1.3 结构配置]`, `[1.1 策略矩阵]`, `[1.2 环节模板]`

### 2. 处理逻辑
1.  **时间切分**：
    -   读取 `[1.3 结构配置]` 中的 `推荐占比` 和 `最大时长(Cap)`。
    -   **热身/放松时长** = Min(`总时长` * `推荐占比`, `最大时长`)。
    -   **主训时长** = `总时长` - `热身时长` - `放松时长`。
    -   *示例*：60分钟课程，热身15%理论为9分钟，但配置Cap=5分钟，故热身=5分钟。
2.  **参数加载 (查表)**：
    -   **查询键**：`课程目标` + `课程难度`。
    -   **查询表**：`[1.1 策略矩阵]`。
    -   **获取参数**：`基准组数`、`基准强度`、`目标RPE`、`休息配置`（是否休息、组间休息时间）、`负荷策略`（递增/恒定/计时）。
3.  **模板匹配 (主训)**：
    -   **查询键**：`目标部位` + `运动等级` + `性别`。
    -   **查询表**：`[1.2 环节模板]`。
    -   **匹配逻辑**：优先精确匹配（部位_等级_性别），无匹配则降级匹配（部位_等级），最后匹配通用模板（部位）。
    -   **产出**：`槽位定义列表`（例如：[复合动作槽位, 占比60%], [孤立动作槽位, 占比40%]）。
4.  **参数修正**：
    -   **输入**：节点 1 传入的 `修正系数`（包含生理周期系数、疲劳系数、计划阶段系数）。
    -   **计算**：
        -   `最终强度` = `基准强度` * `强度修正系数`。
        -   `最终组数` = Round(`基准组数` * `容量修正系数`)，且最小值为 1。

### 3. 输出数据
- **环节列表 (列表<环节对象>)**，每个环节包含：
    -   `环节类型` (热身/主训...)
    -   `环节时长`
    -   `基准参数` (强度/组数/RPE...)
    -   `槽位定义` (列表<槽位>) [仅主训环节]

### 4. 场景示例 
> **场景**：30分钟胸部训练，L3等级。
> - **输入**：时长=30min，部位=胸部，等级=L3。
> - **输出**：
>   - `热身环节`: 4分钟
>   - `主训环节`: 22分钟
>     - `基准参数`: 4组, 强度75%, 组间休90s
>     - `槽位`: [复合推类(60%), 孤立夹类(40%)]
>   - `放松环节`: 4分钟

---

## 节点 4: 动作确认
> 定义：从动作库中筛选最佳动作，填充到规划好的槽位中。
> > *业务导读*：选品上架。从动作库里挑选动作填入槽位。第一步是“安检”，剔除受伤不能做、没器械做不了的动作；第二步是“选秀”，按新鲜感、匹配度给动作打分，分高的入选。

### 1. 输入数据
- **环节列表** (来自 节点 3)
- **约束对象** (伤病/器械，来自 节点 1)
- **动作库** (全量数据)
- **配置表**：`[3.1 推荐因子]`

### 2. 处理逻辑
1.  **全局清洗 (白名单构建)**：
    -   **伤病过滤**：剔除 `疼痛部位` 与 `约束对象.禁忌部位` 有交集的动作。
    -   **器械过滤**：剔除 `动作器械` 不在 `约束对象.可用器械` 列表中的动作。
    -   **产出**：`安全动作池`。
2.  **环节填充循环**：
    -   **热身/放松环节**：
        -   **筛选**：从安全池中选出 `动作功能` 匹配环节类型（如“激活”、“柔韧”）的动作。
        -   **关联**：优先选择与主训 `目标部位` 存在解剖学关联的动作（查阅数据映射表）。
        -   **数量控制**：Min(`环节时长` / 30秒, `[1.3 结构配置].动作数量限制`)。
        -   *逻辑*：避免长热身导致动作过多，强制控制在 4-6 个动作内，通过增加单动作时长或组数来填充时间。
    -   **主训环节**：
        -   **遍历槽位**：对每个槽位（如“复合动作槽位”）：
            -   **初筛 (概率难度匹配)**：
                -   读取 `[2.2 难度兼容策略]` 中的概率分布 (如 {-1: 20%, 0: 60%, 1: 20%})。
                -   生成目标难度：根据概率随机生成当前槽位的 `目标难度` (如随机到了 L+1)。
                -   筛选：从安全池中选出 `动作难度` == `目标难度` 且符合槽位定义的动作。
                -   *注*：若该难度下无动作，则回退到 `用户等级` (L0) 进行筛选。
            -   **打分**：遍历候选动作，计算总分 = Σ(推荐因子权重)。
                -   *新鲜奖励*：+60分（7天未练）。
                -   *匹配奖励*：+100分（完全符合骨架）。
                -   *一致性奖励*：+80分（若处于计划周期内，且上一次同部位训练包含该动作）。
                -   *厌倦惩罚*：-80分（连续3次出现）。
            -   **截取**：按分数降序排列，选取 Top N 个动作填满槽位。
            -   **兜底**：若候选不足，依次执行降级策略直到填满：
                1.  **降难度**：放宽动作难度（如 L3 -> L1-L4）。
                2.  **扩范围**：放宽槽位定义（如“水平推” -> “上肢推”）。
                3.  **改性质**：放宽功能过滤（如“增肌” -> “耐力”）。
                4.  **保骨架**：仅匹配目标部位（如“胸部” -> 任意胸部动作）。
3.  **排序优化**：
    -   **能量管理**：按 `动作构造` 排序，复合动作在前，孤立动作在后。
    -   **减少切换**：在不违反能量管理的前提下，将相同 `动作器械` 或 `动作体位` 的动作聚合。
    -   **超级组配对**：若环节 `循环模式` 为“超级组”，基于 `主动肌-拮抗肌关系表` 将动作两两配对（需校验器械冲突）。
    -   **安全风控**：检查动作序列，若出现连续 2 个以上“高冲击”动作，强制插入低冲击动作打散。

### 3. 输出数据
- **填充后的环节列表**：
    -   每个环节下新增 `动作序列 (列表<动作实例>)`。
    -   动作仅包含 ID 和基础属性，尚未计算重量次数。

### 4. 场景示例 
> **场景**：填充“复合推类”槽位，用户有哑铃。
> - **输入**：槽位=复合推类，安全池包含[杠铃卧推, 哑铃卧推, 俯卧撑]。
> - **过程**：
>   - 杠铃卧推 -> 剔除 (没杠铃)。
>   - 哑铃卧推 -> +100分 (匹配), +60分 (新鲜)。
>   - 俯卧撑 -> +100分 (匹配), -80分 (刚练过)。
> - **输出**：选中 [哑铃卧推]。

---

## 节点 5: 动作实例化
> 定义：原子化计算每个动作的具体负荷（重量/次数/组数）。
> > *业务导读*：精算负荷。给选出来的动作算具体的重量和次数。如果是新动作，就根据你的测评数据推算；如果是老动作，就根据历史记录调整。还会安排每一组的变化，比如第一组轻点，第二组重点。

### 1. 输入数据
- **动作序列** (来自 节点 4)
- **用户能力** (`1RM`, `测评数据`)
- **基准参数** (强度/RPE/负荷策略，来自 节点 3)
- **逻辑库**：`[重量推荐逻辑]`

### 2. 处理逻辑
1.  **模式判定**：
    -   **判断**：检查动作的 `默认计量维度` 和环节的 `负荷策略`。
    -   **分支**：
        -   **负荷优先模式**（力量/增肌）：优先确定重量，次数由重量反推。
        -   **容量优先模式**（有氧/HIIT）：优先确定时长或次数，重量为次要或固定。
2.  **参数计算**：
    -   **分支 A：负荷优先模式**（适用于力量/增肌/塑形）：
        -   **定重量**：调用 `[重量推荐逻辑]`。
            -   有历史：`1RM` * `基准强度` * `遗忘曲线系数`。
            -   无历史：`测评1RM` * `肌肉系数` * `基准强度`。
        -   **定次数**：查阅 `RM百分比表`，将 `基准强度` 转换为 `理论最大次数`，减去 (10 - `目标RPE`) [即 RIR 保留次数] 得到推荐次数。
        -   **定组数**：直接继承环节的 `基准组数`。
    -   **分支 B：容量优先模式**（适用于有氧/HIIT/自重/功能）：
        -   **定容量**：
            -   计时类：根据 `基准强度` 查表得 `推荐时长`（如 L3=45s），次数=0。
            -   计次类：根据 `基准强度` 查表得 `推荐次数`（如 L3=15次），时长=0。
        -   **定重量**：
            -   无电机：设为 0（自重）。
            -   有电机：调用 `[重量推荐逻辑]` 的“基于时长负荷推荐”算法。
        -   **定组数**：直接继承环节的 `基准组数`。
3.  **序列生成**：
    -   **应用策略**：根据 `负荷策略`（如“正金字塔”），生成每组的变化序列。
    -   **示例**：
        -   第1组：重量 85%，次数 +2。
        -   第2组：重量 90%，次数 +1。
        -   第3组：重量 100%，次数 +0。
4.  **时长估算**：
    -   `单组耗时` = (`推荐次数` * `单次动作时长`) + `组间休息`。
    -   `实际环节时长` = Σ(单组耗时)。

### 3. 输出数据
- **实例化动作列表**：
    -   包含完整的 `组序列 (列表<组>)`。
    -   每组包含：`重量`, `次数`, `时长`, `休息时间`。

### 4. 场景示例 
> **场景**：计算“哑铃卧推”的参数，用户1RM=20kg，强度=75%，策略=递增。
> - **输入**：1RM=20kg, 强度=0.75, 策略=递增。
> - **输出**：
>   - 第1组: 12.5kg (20*0.75*0.85), 12次
>   - 第2组: 13.5kg (20*0.75*0.90), 11次
>   - 第3组: 15.0kg (20*0.75*1.00), 10次

---

## 节点 6: 用户微调
> 定义：处理用户在前端的主动修改请求。
> > *业务导读*：最后的把关。把生成好的课程展示给用户，用户如果不喜欢某个动作可以换，觉得太难可以调。系统根据用户的修改指令，实时重新计算参数。

### 1. 输入数据
- **实例化课程** (来自 节点 5)
- **用户指令** (替换动作 / 修改参数 / 调整难度)

### 2. 处理逻辑
1.  **动作替换**：
    -   **输入**：用户指定要替换的 `动作ID`。
    -   **重筛选**：重新运行 **节点 4** 的筛选逻辑，将原动作加入“临时黑名单”，选取评分第二高的动作。
    -   **重计算**：对新动作运行 **节点 5**，计算其重量和次数。
2.  **参数修改**：
    -   **输入**：用户修改了某一组的重量或次数。
    -   **执行**：直接覆写 `组序列` 中的对应数值。
    -   **标记**：为该动作打上 `用户自定义` 标签（后续反馈闭环时权重更高）。
3.  **难度调整**：
    -   **输入**：用户点击“太难了”或“太简单”。
    -   **执行**：全局调整 `强度系数`（如 ±5%）。
    -   **重计算**：遍历所有动作，重新运行 **节点 5** 的重量计算公式。

### 3. 输出数据
- **用户确认后的课程对象**。

### 4. 场景示例 
> **场景**：用户觉得“哑铃卧推”肩膀不舒服，换成“俯卧撑”。
> - **输入**：指令=替换(哑铃卧推)。
> - **处理**：黑名单=[哑铃卧推]，重跑筛选 -> 选中[俯卧撑]。
> - **输出**：更新后的动作列表，其中哑铃卧推变成了俯卧撑。

---

## 节点 7: 数据装配
> 定义：将内部对象转换为前端可渲染的标准 JSON 格式。
> > *业务导读*：打包出厂。把所有算好的数据打包成前端能看懂的标准格式，顺便算出这节课的总卡路里和难度分，生成一句贴心的推荐语。

### 1. 输入数据
- **确认后的课程对象** (来自 节点 6)

### 2. 处理逻辑
1.  **元数据生成**：
    -   生成唯一 `课程ID`。
    -   **推荐理由生成**：提取 **节点 4** 中得分最高的推荐因子（如“针对您的薄弱部位强化”），生成自然语言文案。
2.  **统计计算**：
    -   `总消耗 (千卡)` = Σ(动作MET * 动作时长 * 体重系数)。
    -   `预估RPE` = Σ(环节RPE * 环节时长) / 总时长。
3.  **标签聚合**：
    -   遍历所有动作，收集并去重 `配件要求`、`疼痛部位`、`冲击等级`，生成课程级标签。

### 3. 输出数据
- **标准课程 JSON** (符合《课程属性》定义)。

### 4. 场景示例 
> **场景**：生成最终JSON。
> - **输出**：
>   ```json
>   {
>     "courseId": "CRS_Gen_001",
>     "title": "30分钟胸部增肌",
>     "calories": 150,
>     "tags": ["哑铃", "低冲击"],
>     "reason": "根据您的恢复状态推荐"
>   }
>   ```

---

## 节点 8: 反馈闭环
> 定义：课程执行后的数据闭环，不参与生成，但影响下一次生成。
> > *业务导读*：课后复盘。练完之后，系统会根据你反馈的“累不累”（RPE）来调整你的能力值，根据你“换动作”的行为来调整你的偏好。越练越懂你。

### 1. 输入数据
- **执行数据** (实际完成的重量/次数)
- **用户反馈** (课后RPE, 替换行为, 收藏行为)

### 2. 处理逻辑
1.  **能力校准**：
    -   **RPE 校验**：若 |`用户反馈RPE` - `预估RPE`| > 2：
        -   反馈过累：下调该部位的 `强度系数` (如 -5%)。
        -   反馈过轻：上调该部位的 `强度系数` (如 +5%)。
    -   **1RM 更新**：若 `实际训练重量` > `当前1RM`，则立即更新档案中的 `1RM` 数据。
2.  **偏好学习**：
    -   **冷宫逻辑**：若某动作被用户主动替换累计超过 3 次 -> 加入 `冷宫池`（在 **节点 4** 筛选时给予 -50 分惩罚）。
    -   **加分逻辑**：若用户收藏某动作 -> 加入 `加分池`（在 **节点 4** 筛选时给予 +50 分奖励）。
3.  **平台期识别**：
    -   **判断**：若某部位连续 5 次训练的 `推荐重量` 未提升。
    -   **标记**：将该部位标记为 `平台期`。
    -   **影响**：下次生成时，**节点 3** 将自动切换 `负荷策略`（如从“推荐”切换为“递减”）。

### 3. 输出数据
- **更新后的用户档案**。

### 4. 场景示例 
> **场景**：用户反馈RPE=9（太累），预估RPE=7。
> - **输入**：反馈RPE=9, 预估RPE=7。
> - **处理**：偏差=2，触发下调逻辑。
> - **输出**：更新档案，胸部强度系数 1.0 -> 0.95。

## 需求池
> > *业务导读：未来版本规划的逻辑模块。*
1. **波浪负荷策略**：在平台期干预中引入波浪周期策略。