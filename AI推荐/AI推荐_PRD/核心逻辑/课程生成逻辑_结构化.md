# 课程生成逻辑
> **文档用途**：本文档是算法落地的“施工图纸”。
> - **产品经理**：请重点关注“业务导读”和“场景示例”，确认逻辑是否符合业务预期。
> - **开发人员**：请重点关注“输入/输出”和“处理逻辑”，这是代码实现的直接依据。
> **设计原则**：高内聚，低耦合。每个节点仅依赖明确的输入，产出标准化的输出。

## 节点流转总览
```mermaid
graph LR
    N1[输入与上下文] --> N2[课程确认]
    N2 --> N3[环节确认]
    N3 --> N4[动作确认]
    N4 --> N5[动作实例化]
    N5 --> N6[用户微调]
    N6 --> N7[数据装配]
    N7 --> N8[反馈闭环]
```

---

## 节点 1: 输入与上下文
> 定义：确立课程生成的“主干意图”（来源：用户或计划）与“边界约束”（来源：环境与状态）。
> > *业务导读*：就像教练在开课前进行的“摸底访谈”。系统需要收集你的基本信息、当下的需求（想练哪里、练多久）以及限制条件（有没有受伤、有什么器械），把这些信息打包成一个“上下文包”，传给后面的环节。

### 1. 输入数据
- **用户档案** (来源: 运动档案)：
    -   *基础数据*：`性别`、`生日`、`身高`、`体重`、`BMI`、`静息心率（RHR）`、`最大心率（MHR）`、`主观疲劳度`。
    -   *偏好设置*：`运动等级`、`每周训练日`、`每周运动频率`、`每日运动时长`、`疼痛部位`、`没有的器械`。
    -   *目标设定*：`主要目标`、`功能目标`、`目标体型`、`目标体重`。
    -   *能力数据*：`1RM记录`。
- **场景入口**：
    -   *用户输入* (单课模式)：`课程类型`、`目标部位`、`单课时长`、`单课环节` (热身/主训/放松，默认全选)。
    -   *计划上下文* (计划模式)：`课程类型`、`侧重维度`、`侧重目标`、`课程时长`、`单课环节`、`环节模板`、`阶段目标`、`阶段系数` (强度/容量)。
- **状态数据**：`综合疲劳度`、`部位状态值`。

### 2. 处理逻辑
1.  **步骤 1: 训练意图解析**
    > *目的：统一“计划模式”与“单课模式”的输入差异，输出标准化的训练需求。*
    -   **计划模式**：解析计划上下文中的参数。
        -   *规则*：若 `计划上下文` 存在。
        -   *规则*：`来源模式` = "计划"。
        -   *规则*：`基准类型` = `计划上下文.课程类型`。
        -   *规则*：`基准目标` = [`计划上下文.侧重目标`] (标准化为列表)。
        -   *规则*：`基准时长` = `计划上下文.课程时长`。
        -   *规则*：`基准环节` = `计划上下文.单课环节`。
    -   **单课模式**：解析用户输入的单课参数。
        -   *规则*：若不存在 `计划上下文`。
        -   *规则*：`来源模式` = "单课"。
        -   *规则*：`基准类型` = `用户输入.课程类型`。
        -   *规则*：`基准目标` = `用户输入.目标部位`。
        -   *规则*：`基准时长` = `用户输入.单课时长` (若空 → 取 `档案.每日运动时长`)。
        -   *规则*：`基准环节` = `用户输入.单课环节` (若空 → 默认 ["热身", "主训", "放松"])。

2.  **步骤 2: 限制条件识别**
    > *目的：识别身体和环境的红线，确保生成的课程安全可行。*
    -   **疲劳风控**：基于疲劳度识别风险。
        -   *规则*：`全局`：若 `综合疲劳度` < 55 → 标记 `推荐降级`（难度降低） = True。
        -   *规则*：`局部`：识别 `力竭部位` (`部位状态值` < 30)。
        -   *规则*：`智能推荐部位`：识别 `部位状态值` > 85 (已恢复) 的部位集合。
    -   **硬件环境**：计算可用器械集合。
        -   *规则*：`可用器械` = `全量器械库` - `档案.没有的器械`。
    -   **身体限制**：聚合所有禁忌部位。
        -   *规则*：`禁忌部位` = `档案.疼痛部位` ∪ `力竭部位` (来自疲劳风控)。

3.  **步骤 3: 智能缺口填充**
    > *目的：当用户输入不完整时，基于算法自动补全最优策略。*
    -   **类型补全**：自动推导缺失的课程类型。
        -   *规则*：若 `基准类型` 为空 → 基于 `档案.功能目标` 映射 (如: 增肌->力量, 减脂->HIIT)。
    -   **目标补全**：自动推荐缺失的训练目标。
        -   *规则*：若 `基准目标` 为空 → 优先推荐 `智能推荐部位` (状态好)；若无 `智能推荐部位` (全身疲劳) → 默认 "恢复" (主动恢复)。
    -   **时长补全**：设定默认时长。
        -   *规则*：若 `基准时长` 为空 → 默认 30min。

4.  **步骤 4: 数据完整性校验**
    > *目的：最后一道防线，防止脏数据进入下游。*
    -   **完整性校验**：确保核心参数不为空。
        -   *规则*：校验 `基准目标` && `基准时长` && `基准环节` 及核心档案字段。

### 3. 输出数据
- **上下文对象**：
    -   *基础上下文*：`来源模式`、`计划上下文`。
    -   *基准参数*：`基准类型`、`基准目标`、`基准时长`、`基准环节`。
    -   *约束条件*：`可用器械`、`禁忌部位`、`智能推荐部位`、`推荐降级`。
    -   *状态数据*：`状态数据`。

### 4. 场景示例 
> **场景**：一个膝盖有伤的用户，单课模式想练胸，只有哑铃，且时间紧迫只做主训。
> - **输入**：课程类型="力量"，目标部位="胸部"，单课环节=["主训"]，档案.疼痛部位="膝盖"，档案.没有的器械=["杠铃", "固定器械"]。
> - **输出**：
>   - `基准类型`: 力量
>   - `基准目标`: ["胸部"]
>   - `基准时长`: 30 (默认补全)
>   - `基准环节`: ["主训"]
>   - `可用器械`: ["哑铃", "自重"]
>   - `禁忌部位`: ["膝盖"] (后续会剔除深蹲等动作)
>   - `推荐降级`: False
>   - `状态数据`: 正常
>   - `计划上下文`: Null

---

## 节点 2: 课程确认
> 定义：基于上下文环境，裁决并确立课程的宏观属性。
> > *业务导读*：给这节课定调。确定主题是“增肌”还是“减脂”，难度是“入门”还是“专业”。

### 1. 输入数据
- **上下文对象** (来源: 节点 1)：
    -   `来源模式` (单节课/计划课)、`基准类型`、`基准目标`、`基准时长`、`推荐降级`、`计划上下文` (计划课专用)。
- **用户档案** (来源: 运动档案)：
    -   *偏好设置*：`运动等级`。
    -   *目标设定*：`功能目标`。

### 2. 处理逻辑
1.  **步骤 1: 目标冲突裁决**
    > *目的：解决“想练的部位”和“不能练的部位”之间的冲突。*
    -   **冲突检测**：检查目标部位是否在禁忌列表中。
        -   *规则*：检查 `上下文.基准目标` ∩ `上下文.禁忌部位` ≠ Ø。
    -   **冲突处理**：根据来源模式执行不同的冲突解决策略。
        -   *规则*：**计划模式**：触发 `部位替换策略` (如：胸部力竭 → 改练 `智能推荐部位` 或 "主动恢复")。
        -   *规则*：**单课模式**：前端提示风险 → 若用户坚持 → 标记 `推荐降级` = True；若用户接受建议 → `最终目标` = `智能推荐部位`。
    -   **最终定案**：输出经过裁决的目标部位。
        -   *规则*：输出 `最终目标部位`。

2.  **步骤 2: 难度基准定级**
    > *目的：确定课程的难度等级，并根据状态进行降级保护。*
    -   **确立基准**：根据用户档案设定初始难度。
        -   *规则*：`课程难度` = `档案.运动等级` (如 L3)。
    -   **执行修正**：处理降级逻辑。
        -   *规则*：若 `上下文.推荐降级` == True → `课程难度` 下调 2级 (最低 L1)。

3.  **步骤 3: 属性初始化**
    > *目的：补全课程类型、时长和生理目标。*
    -   **课程类型**：确定课程的运动种类。
        -   *规则*：`上下文.基准类型` (若空 → 映射自 `档案.功能目标`)。
    -   **课程时长**：确定课程总时长。
        -   *规则*：`上下文.基准时长`。
    -   **课程目标**：确定课程的生理训练目标。
        -   *规则*：若 `计划上下文` 存在：
            -   若 `计划上下文.侧重维度` == "动作功能" → 取 `计划上下文.侧重目标` (如: 计划是增肌，但此槽位是心肺)。
            -   否则 → 取 `计划上下文.阶段目标`。
        -   *规则*：否则 (单课模式) → 取 `档案.功能目标`。
    -   **目标部位**：确定训练部位。
        -   *规则*：若 `课程类型` ∈ [HIIT, 有氧] → 强制覆写为 ["全身"]。
        -   *规则*：否则 → 取 `上下文.基准目标`。

4.  **步骤 4: 解剖部位解析**
    > *目的：将抽象的动作模式（如水平推）翻译成具体的肌肉部位（如胸部）。*
    -   **解析逻辑**：将抽象维度转换为具体解剖部位。
        -   *规则*：若 `最终目标部位` 为 "动作模式" (如水平推) → 查阅 `[数据映射.md] - [动作模式与主练部位映射]` → 转换为 `解剖部位`。
        -   *规则*：若 `最终目标部位` 为 "动作功能" (如心肺) → 转换为 "全身"。

### 3. 输出数据
- **课程元数据** (流转至: 节点 3)：
    -   *推荐标签*：`课程类型`、`课程目标`、`目标部位`、`课程难度`。
    -   *基础信息*：`课程时长`。

### 4. 场景示例
> **场景**：L3等级用户，单课模式目标增肌，但今天很累（触发降级）。
> - **输入**：等级=L3，推荐降级=True，功能目标="增肌"。
> - **输出**：
>   - `课程难度`: L1 (L3 - 2级)
>   - `课程类型`: 力量
>   - `课程目标`: 增肌 (继承自档案)
>   - `课程时长`: 30 (继承)
>   - `目标部位`: ["全身"] (智能推荐部位)

---

## 节点 3: 环节确认
> 定义：规划课程的时间结构，并加载各环节的基准训练参数。
> > *业务导读*：切分时间蛋糕。把总时长切分为“热身、主训、放松”三块。同时，根据你的等级查阅“配方表”，确定主训要做几组、休息多久、强度多大。

### 1. 输入数据
- **课程元数据** (来源: 节点 2) [通用]：
    -   *推荐标签*：`课程类型`、`课程目标`、`目标部位`、`课程难度`。
    -   *基础信息*：`课程时长`。
- **上下文对象** (来源: 节点 1) [通用]：
    -   `计划上下文` (计划课专用 - 用于匹配环节模板)、`状态数据`。
- **用户档案** (来源: 运动档案)：
    -   *偏好设置*：`运动等级`。
    -   *基础数据*：`性别`。
- **配置表**：
    -   `[1.3 结构与组装配置]`、`[1.1 策略矩阵配置]`、`[1.2 课程环节模板配置]`。

### 2. 处理逻辑
1.  **步骤 1: 时间结构规划**
    > *目的：切分课程总时长，确定各环节的时间预算。*
    -   **切分计算**：依据 `[1.3 结构与组装配置]` 进行切分。
        -   *规则*：`热身/放松时长` = Min(`课程时长` * `推荐占比`, `最大时长`)。
        -   *规则*：`主训时长` = `课程时长` - `热身时长` - `放松时长`。

2.  **步骤 2: 策略参数加载**
    > *目的：确定各环节的训练基调（强度、组数、休息）。*
    -   **遍历环节**：对 `热身`、`主训`、`放松` 分别执行参数加载。
        -   **确定策略键**：根据环节类型确定查表Key。
            -   *规则*：`热身` → Key="激活" (默认) 或 "心肺" (若主训为减脂)。
            -   *规则*：`主训` → **配置上下文映射**：
                -   若 `课程类型` 为强属性 (HIIT/瑜伽/有氧/普拉提/拉伸) → Key=`课程类型`。
                -   若 `课程类型` 为弱属性 (力量/康复) → Key=`课程目标`。
            -   *规则*：`放松` → Key="柔韧" (默认) 或 "恢复"。
        -   **加载基准参数**：查阅 `[1.1 策略矩阵配置]`。
            -   *规则*：获取 `基准组数`, `组间休息`, `负荷策略`, `训练强度`, `循环模式` 等。
        -   **周期化修正**：若存在 `计划上下文.阶段系数`，修正基准参数。
            -   *规则*：`动作组数` = Round(`基准组数` * `阶段系数.容量系数`)。
            -   *规则*：`训练强度` = `基准强度` * `阶段系数.强度系数`。
            -   *注*：此步骤确保“减载期”或“突破期”的宏观策略能落实到单节课的负荷上。

3.  **步骤 3: 训练范式适配**
    > *目的：根据课程类型调整底层逻辑（如瑜伽课不按组数算）。*
    -   **范式映射**：引用 `[1.6 训练范式配置]` 确定范式。
        -   *规则*：根据 `课程类型` 映射 `训练范式`。
    -   **参数覆盖**：根据范式调整默认参数。
        -   *规则*：**抗阻范式** (主训)：沿用基准参数。
        -   *规则*：**间歇范式** (HIIT)：强制 `循环模式`="循环组", `负荷策略`="计时", `休息配置`=True。
        -   *规则*：**流式范式** (瑜伽)：强制 `动作组数`=1, `休息配置`=False, `负荷策略`="计时"。

4.  **步骤 4: 容量规划计算**
    > *目的：计算每个环节能容纳多少个动作。*
    -   **计算单动作耗时**：根据范式计算单个动作的完整周期耗时。
        -   *规则*：若 `环节类型` ∈ [热身, 放松] 或 `训练范式` != "抗阻范式" → `单组耗时` = `[数据映射.md] - [4. 强度指标换算映射].计时时长` + `组间休息`。
        -   *规则*：若 `训练范式` == "抗阻范式" (主训) → `单组耗时` = 45s (TUT估算) + `组间休息`。
        -   *规则*：`标准耗时` = `策略.基准组数` (未修正值) * `单组耗时`。
        -   *规则*：`完整周期耗时` = `标准耗时` + `轮间休息` (若有，否则为0)。
    -   **计算目标数量**：计算环节内能容纳的最大动作数。
        -   *规则*：`目标数量` = Min(向下取整(`环节时长` / `完整周期耗时`), `配置.动作数量限制`)。
        -   *注*：使用未修正的基准组数计算动作量，确保减载期(容量系数<1)动作数量不虚高，落实减量策略。
        -   *注*：因热身/放松配置中 `组间休息`=0，此处自动实现无间歇流式计算。
    -   **时间-容量自适应 (Time-Constraint Adaptation)** [新增]：
        -   *目的*：解决短时长课程中因单动作耗时过长导致动作数量过少（<3个）的问题。
        -   *策略1 (休息压缩)*：若 `课程时长` ≤ 30min，基于 `课程目标` 差异化压缩：
            -   **力量/爆发**：强制 `组间休息` ≤ 120s (底线，保神经恢复)。
            -   **增肌/塑形**：强制 `组间休息` ≤ 60s (追求代谢压力)。
            -   **减脂/心肺**：强制 `组间休息` ≤ 45s (追求高心率)。
            -   重算 `单组耗时`。
        -   *规则*：若 `目标数量` < 3 && `策略.基准组数` > 2：
            -   *策略2 (组数降级)*：尝试降低组数以换取多样性。
            -   `适配组数` = Max(2, Min(`策略.基准组数`, 向下取整(`环节时长` / 3 / `单组耗时`)))。
            -   更新 `环节.动作组数` = `适配组数`。
            -   重算 `完整周期耗时` 并更新 `目标数量`。

5.  **步骤 5: 内容配方加载 (仅主训)**
    > *目的：确定主训环节的具体动作槽位分布。*
    -   **查表**：查询 `[1.2 课程环节模板配置]` 获取配方。
        -   *规则*：Key: `目标部位` && `课程目标` && `运动等级` && `性别`。
    -   **匹配逻辑**：确定模板匹配的优先级。
        -   *规则*：`计划上下文` 指定 > 精确匹配 > 降级匹配 > 通用匹配。
    -   **槽位分配**：计算各槽位的具体动作数量。
        -   *规则*：将 `主训目标数量` 按模板比例分配给各 `槽位` (采用最大余额法处理整数余数，确保总数守恒)。

### 3. 输出数据
- **环节列表** (流转至: 节点 4)：
    -   *基础信息*：`环节类型`。
    -   *训练配置*：`环节时长`、`动作组数`、`训练强度`、`休息配置`、`组间休息`、`轮间休息`、`负荷策略`、`循环模式`、`难度策略`、`动作节奏`、`关联环节模板`。
    -   *动作配置*：`目标动作数`、`槽位列表`。

### 4. 场景示例
> **场景**：60分钟胸部训练，L3等级（高容量，抗阻范式）。
> - **输入**：时长=60min，部位=胸部，等级=L3，课程目标=增肌。
> - **输出**：
>   - `热身环节`: 5分钟 (目标动作: 3个) [L3基准: 2组×45s+0s休息=90s/个, 300/90≈3.3]
>   - `主训环节`: 50分钟 (目标动作: 5个)
>     - `基准参数`: 4组, 强度75%, 组间休90s (单动作耗时: 4×(45+90)=540s)
>     - `槽位`: [复合推类(3个), 孤立夹类(2个)] (50×60/540≈5.5)
>   - `放松环节`: 5分钟 (目标动作: 3个) [L3基准: 2组×45s+0s休息=90s/个, 300/90≈3.3]

---

## 节点 4: 动作确认
> 定义：从动作库中筛选最佳动作，填充到规划好的槽位中。
> > *业务导读*：选品上架。从动作库里挑选动作填入槽位。第一步是“安检”，剔除受伤不能做、没器械做不了的动作；第二步是“选秀”，按新鲜感、匹配度给动作打分，分高的入选。

### 1. 输入数据
- **环节列表** (来源: 节点 3)：
    -   *基础信息*：`环节类型`。
    -   *动作配置*：`槽位列表`、`目标动作数`。
- **上下文对象** (来源: 节点 1)：
    -   `可用器械`、`禁忌部位`、`推荐降级`。
- **动作库** (来源: 数据库)。
- **配置表**：
    -   `[3.1 推荐影响因子配置]`、`[2.2 难度兼容策略配置]`。

### 2. 处理逻辑
1.  **步骤 1: 安全过滤**
    > *目的：建立绝对安全的动作白名单，剔除所有硬性风险。*
    -   **伤病过滤**：剔除与用户疼痛部位冲突的动作。
        -   *规则*：`动作.疼痛部位` ∩ `上下文.禁忌部位` ≠ Ø → 剔除。
    -   **器械过滤**：剔除用户缺乏对应器械的动作。
        -   *规则*：`动作.动作器械` ⊈ `上下文.可用器械` → 剔除。
    -   **冲击风控**：针对高冲击动作的额外保护逻辑。
        -   *规则*：若 `动作.冲击等级` == "高冲击"，执行以下检查：
            -   **关节保护**：保护膝盖和脚踝关节。
                -   *规则*：`上下文.禁忌部位` ∩ {膝盖, 脚踝} ≠ Ø → 剔除。
            -   **体重保护**：大体重低等级用户规避高冲击。
                -   *规则*：`档案.BMI` ≥ 28 && `档案.运动等级` < L4 → 剔除 (L4/L5高阶用户肌肉量大，可豁免)。
            -   **状态保护**：疲劳状态下的降级保护。
                -   *规则*：`上下文.推荐降级` == True → 剔除。
    -   **产出**：`安全动作池`。

2.  **步骤 2: 功能匹配**
    > *目的：基于槽位定义进行宽泛召回，最大化候选池，避免过早过滤导致局部最优。*
    -   **遍历逻辑**：针对每个待填充的空缺进行处理。
        -   *规则*：遍历 `环节列表` → `槽位列表`。
    -   **热身/放松**：
        -   **热身**：匹配热身相关功能。
            -   *规则*：`动作功能` ∈ {心肺, 激活, 协调, 平衡, 柔韧}。
            -   *一致性校验 (分级策略)*：
                -   **L1 (精准)**：`动作部位集合` (主/次) ∩ `课程目标部位` ≠ Ø。
                -   **L2 (通用)**：`动作.主要部位` == "全身" && `动作.次要部位` 为空。
                -   **L3 (兜底)**：若上述无匹配，仅匹配 `动作功能` (放宽部位限制)。
        -   **放松**：匹配放松相关功能。
            -   *规则*：`动作功能` ∈ {柔韧, 恢复, 体态, 呼吸}。
            -   *一致性校验 (分级策略)*：同上。
    -   **主训**：
        -   **属性匹配**：确保动作属性符合槽位要求。
            -   *规则*：`动作属性` ⊆ `槽位定义` (部位/模式/功能)。
    -   **产出**：`候选动作列表`。

3.  **步骤 3: 推荐评分**
    > *目的：将所有软性约束转化为分值，通过竞价机制选出最优解。*
    -   **计算总分**：引用 `[3.1 推荐影响因子配置]`。
    -   **加分项**：
        -   `新鲜奖励`：近期未练 (+60分)。
            -   *规则*：`当前日期` - `上次训练日期` > `配置.新鲜周期` (7天)。
        -   `收藏奖励`：用户收藏 (+50分)。
            -   *规则*：`动作.是否收藏` == True。
        -   `探索奖励`：历史训练次数 == 0 (+30分)。
            -   *规则*：`用户历史训练次数` == 0。
        -   `完赛信心奖励`：缺勤回归建立信心 (+20分)。
            -   *规则*：`连续缺勤天数` > `配置.缺勤定义` (7天) && `历史平均完成度` > `配置.高完成度` (0.95)。
    -   **减分项**：
        -   `厌倦惩罚`：近期频繁出现 (-80分)。
            -   *规则*：`连续出现次数` ≥ `配置.厌倦阈值` (3次)。
        -   `冷宫惩罚`：用户主动厌恶/替换动作 (-50分)。
            -   *规则*：`当前日期` - `上次移除日期` ≤ `配置.冷宫周期` (30天)。
        -   `疲劳惩罚`：辅助肌处于疲劳状态 (-50分)。
            -   *规则*：`辅助肌.状态值` < `配置.疲劳阈值` (55)。
    -   **随机扰动** [新增]：
        -   *目的*：打破确定性排序导致的局部最优解（避免每次生成结果完全一致）。
        -   *规则*：`最终得分` = `基础得分` + `Random(0, 15)`。
    -   **产出**：`评分后的候选列表`。

4.  **步骤 4: 难度匹配**
    > *目的：基于难度策略确定目标难度，并据此筛选难度最合适的动作。*
    -   **难度分配**：确定当前槽位的目标难度。
        -   *规则*：基于 `环节.难度策略` (引用 `[2.2 难度兼容策略配置]`) 抽取当前槽位的 `目标难度`。
        -   *示例*：L3用户策略 -> 60%概率抽中L3, 20%抽中L2, 20%抽中L4。
    -   **难度分层**：构建分级候选池。
        -   **T1 (首选)**：难度完全匹配。
            -   *规则*：筛选 `动作难度` == `目标难度` 的动作。
        -   **T2 (次选)**：难度兼容范围。
            -   *规则*：筛选 `动作难度` == `目标难度 ± 1` 的动作。
        -   **T3 (兜底)**：剩余候选动作。
            -   *规则*：所有其他候选动作。

5.  **步骤 5: 竞价与择优**
    > *目的：基于总分择优录取，优先满足高权重槽位。*
    -   **排序**：在各层级内按 `推荐总分` 降序排列。
    -   **择优策略** [新增]：
        -   *规则*：优先从 T1 选取；若 T1 不足则从 T2 选取...；针对每个待填充槽位，从当前层级 Top 3 (或配置值) 中随机抽取 1 个。
        -   *目的*：打破“永远只选第一名”的僵化逻辑，避免局部最优解，增加课程变化。
    -   **填充**：循环抽取直到满足 `槽位.目标数量` 或 `候选池耗尽`。

6.  **步骤 6: 兜底与填充**
    > *目的：处理动作不足的极端情况，通过放宽约束或增加组数保证课程完整性。*
    -   **约束放宽**：
        -   *规则*：若 `已选动作数` < `目标数量`，按以下优先级逐步放宽约束，重新调用 `[步骤 2: 功能匹配]` 获取新候选池并执行 `[步骤 5: 竞价与择优]`：
        -   1. **扩范围**：将 `槽位定义.动作模式` 替换为对应的 `主要部位` 约束。
            -   *规则*：查阅 `[数据映射.md]`，将具体的模式 (如 "水平推") 泛化为部位约束 (如 "胸部")，但保留 `动作构造` (复合/孤立) 约束。
        -   2. **放宽难度**：移除 `配置.难度兼容范围` 约束。
            -   *规则*：允许 `动作难度` ∈ [L1, L5] 的所有动作进入候选池 (忽略用户等级限制)。
        -   3. **改性质**：移除 `槽位定义.动作功能` 约束。
            -   *规则*：不再校验动作的功能标签 (如允许 "耐力" 动作进入 "增肌" 槽位)。
        -   4. **保骨架**：仅保留 `主要部位` 匹配。
            -   *规则*：只要 `动作.主要部位` == `槽位.侧重目标` (或 `课程.目标部位`) 即可，忽略所有其他属性 (包括动作构造)。
        -   **致命失败**：处理无法生成的情况。
            -   *规则*：若放宽至最低限度仍无动作 (如空库或极端限制) → 抛出 `生成失败异常`，前端捕获并引导用户修改约束 (如“请添加器械”或“修改目标”)。
    -   **缺口填充**：
        -   *目的*：当动作库彻底耗尽仍未填满槽位时，通过调整组数填补时长缺口。
        -   *规则*：
            -   若 `计划上下文.容量系数` < 1.0 (减载期) → **跳过填充** (允许提前结束)。
            -   否则 → 增加已选动作的 `组数` (每缺1个动作，前序动作轮流 +1 组)，直到满足时长预算。
        -   **熔断限制**：防止单动作组数过多。
            -   *规则*：单个动作最大组数 ≤ 6。
        -   **降维填充**：引入辅助动作填补剩余缺口。
            -   *规则*：若达到组数上限仍有缺口 → 引入 `辅助部位` 动作 (如练腿不足补核心)。

7.  **步骤 7: 序列编排**
    > *目的：微调动作顺序，优化实际执行体验。*
    -   **优先级执行**：按以下优先级顺序执行排序（高优先级覆盖低优先级）：
        -   1. **安全风控**：防止连续高冲击带来的风险。
            -   *规则*：若 `连续高冲击` > 3 → 插入低冲击动作。
        -   2. **基准策略**：应用环节模板定义的排序逻辑。
            -   *规则*：引用 `[1.3 结构与组装配置] - D. 排序策略定义`。
            -   **体能分配**：按 `动作构造` (复合>孤立) 及 `参与肌群大小` 降序排列。
            -   **顺序执行**：保持槽位填充时的原始顺序。
            -   **交替执行**：按槽位索引奇偶交叉重排 (A1, B1, A2, B2...)。
            -   **流式优化**：调用 `TSP算法` (旅行商问题变种) 寻找体位切换成本最低的路径。
        -   3. **逻辑约束**：
            -   **超级组配对**：若 `模式` == "超级组" → 配对 (`主动肌`, `拮抗肌`)。
            -   **核心后置**：若包含 `核心` 动作且非核心专项课 → 移动至序列末尾 (避免核心提前疲劳)。
        -   4. **体验优化** (权重排序)：
            -   **器械聚合**：聚合 `相同器械` (基于 `动作.动作器械`，减少换器械时间)。
            -   **硬件聚合**：聚合 `相似力臂挡位` (一次训练中调节不超过3次，每次不超过2个自由度)。
            -   **动作流**：调整顺序，使 `体位变换成本` 最低 (基于 `动作.动作体位`，如：站姿->站姿->坐姿->仰卧)。

### 3. 输出数据
- **填充后的环节列表** (流转至: 节点 5)：
    -   *动作配置*：`动作序列` (含ID及基础属性)。

### 4. 场景示例
> **场景**：填充“复合推类”槽位，用户有哑铃。
> - **输入**：槽位=复合推类，安全池包含[杠铃卧推, 哑铃卧推, 俯卧撑]，用户器械=[哑铃]。
> - **过程**：
>   - 杠铃卧推 → 剔除 (没杠铃)。
>   - 哑铃卧推 → +100分 (匹配), +60分 (新鲜)。
>   - 俯卧撑 → +100分 (匹配), -80分 (刚练过)。
> - **输出**：选中 [哑铃卧推]。

---

## 节点 5: 动作实例化
> 定义：计算每个动作的具体执行参数（重量/次数/组数）。
> > *业务导读*：精算负荷。给选出来的动作算具体的重量和次数。如果是新动作，就根据你的测评数据推算；如果是老动作，就根据历史记录调整。还会安排每一组的变化，比如第一组轻点，第二组重点。

### 1. 输入数据
- **动作序列** (来源: 节点 4)。
- **基准参数** (来源: 节点 3)：
    -   `训练强度`、`负荷策略`、`动作组数`。
- **用户档案** (来源: 运动档案)：
    -   *能力数据*：`1RM记录`、`部位测评1RM`。
- **逻辑库**：`[重量推荐逻辑]`。
- **配置表**：`[2.1 负荷与组间策略配置]`、`[重量推荐逻辑.md] - [3.1 RM与百分比换算表]`、`[数据映射.md] - [4. 强度指标换算映射]`。

### 2. 处理逻辑
1.  **步骤 1: 计算模式判定**
    > *目的：决定算法是优先算重量还是优先算次数。*
    -   **判定逻辑**：确定计算优先级。
        -   *规则*：若 `训练范式` == "抗阻范式" && `动作.默认计量维度` != "计时" → **负荷优先模式**。
        -   *规则*：否则 (间歇/流式范式 或 计时动作) → **容量优先模式**。

2.  **步骤 2: 基准参数计算**
    > *目的：计算动作的标准负荷锚点（即“100%强度”时的参数）。*
    -   **若为 [负荷优先模式]**：
        -   **定重量**：计算基准重量。
            -   *规则*：调用 `[重量推荐逻辑]` (输入: `1RM记录` || `测评数据`, `环节.训练强度`) → `基准重量`。
        -   **定次数**：计算理论最大次数。
            -   *规则*：查阅 `[3.1 RM与百分比换算表]` (输入: `环节.训练强度`) → `理论最大次数`。
        -   **RPE修正**：基于RPE调整次数。
            -   *规则*：`基准次数` = Max(1, `理论最大次数` - (10 - `环节.目标RPE`))。
            -   *注*：RPE 8 代表保留 2 次 (10-8)，即做 10RM 的重量只做 8 个。
    -   **若为 [容量优先模式]**：
        -   **定容量**：计算基准容量。
            -   *规则*：查阅 `[4. 强度指标换算映射]` (输入: `环节.训练强度`) → `基准时长` (计时) || `基准次数` (计次)。
        -   **定重量**：适配力量模组重量。
            -   *规则*：若 `动作.力量模组` == "是" → 调用 `[重量推荐逻辑]` (基于时长适配)；否则 `基准重量` = 0。

3.  **步骤 3: 组间策略序列生成**
    > *目的：生成每一组的具体参数（第一组轻，第二组重...）。*
    -   **应用策略**：加载组间变化策略。
        -   *规则*：引用 `[2.1 负荷与组间策略配置]` (依据: `环节.负荷策略`)。
    -   **序列展开**：生成每组具体参数。
        -   *规则*：遍历 `环节.动作组数`，对每一组应用 `负荷系数` 和 `次数增量`。
        -   *规则*：`当前组重量` = `基准重量` * `负荷系数`。
        -   *规则*：`当前组次数` = `基准次数` + `次数增量` (或 `当前组时长` = `基准时长` * `负荷系数`)。
        -   *规则*：`当前组休息` = `环节.组间休息`。

4.  **步骤 4: 执行时长估算**
    > *目的：计算动作的总耗时，用于课程总时长统计。*
    -   **单次耗时**：计算单次动作时间。
        -   *规则*：若 `环节.动作节奏` (如 "2-0-2-0") 存在 → `单次耗时` = Sum(节奏) (4s)。
        -   *规则*：否则 → `单次耗时` = `动作.单次动作时长`。
    -   **单组执行时长**：计算单组净运动时间。
        -   *规则*：计次：`执行时长` = `当前组次数` * `单次耗时`。
        -   *规则*：计时：`执行时长` = `当前组时长`。
    -   **单边修正**：处理单边动作时长。
        -   *规则*：若 `动作.单边独立性` == True → `执行时长` = `执行时长` * 2 + 5s (换边缓冲)。
    -   **总耗时**：汇总课程总时长。
        -   *规则*：Sum(`每组执行时长` + `每组休息时间`)。

### 3. 输出数据
- **实例化课程** (流转至: 节点 6)：
    -   *动作配置*：`实例化动作列表` (含组序列: 重量/次数/时长/休息/单组耗时)。

### 4. 场景示例
> **场景**：计算“哑铃卧推”的参数，用户1RM=20kg，强度=75%，策略=递增。
> - **输入**：1RM=20kg, 强度=0.75 (基准重量15kg), 策略=递增 (系数: 0.85/0.90/1.0), 基准次数=10。
> - **输出**：
>   - 第1组: 12.5kg (15*0.85), 12次 (10+2)
>   - 第2组: 13.5kg (15*0.90), 11次 (10+1)
>   - 第3组: 15.0kg (15*1.00), 10次 (10+0)

---

## 节点 6: 用户微调
> 定义：响应用户在前端的主动修改请求，实时重算课程参数。
> > *业务导读*：最后的把关。把生成好的课程展示给用户，用户如果不喜欢某个动作可以换，觉得太难可以调。系统根据用户的修改指令，实时重新计算参数。

### 1. 输入数据
- **实例化课程** (来源: 节点 5)。
- **用户指令** (来源: 前端交互)：
    -   **结构指令**：`重置生成` (修改输入)、`环节增减` (如删除热身)、`动作排序`、`动作删除`。
    -   **内容指令**：`动作替换`、`器械切换` (如哑铃换杠铃)。
    -   **参数指令**：`修改负荷` (重量/次数/组数/时长)、`修改策略` (负荷策略/循环模式)、`全局难度`。

### 2. 处理逻辑
1.  **步骤 1: 全局重构处理**
    > *目的：响应影响课程整体结构的重大修改。*
    -   **重置生成**：响应核心参数变更。
        -   *规则*：若用户修改 `目标部位` / `课程时长` / `课程类型` → 携带新参数重新调用 `[节点 2: 课程确认]` 及后续流程 (State Re-entry)。
    -   **环节增减**：响应环节的增删操作。
        -   *规则*：若 `删除环节` (如不要热身) → 该环节 `目标动作数` 置 0，时长释放。
        -   *规则*：若 `增加环节` → 调用 `[节点 3: 环节确认]` 获取默认参数。
        -   **时长平衡策略**：决定释放时长的去向。
            -   *规则*：释放的时长可选择 `填充至主训` 或 `缩短总课时` (默认缩短)。

2.  **步骤 2: 动作筛选微调**
    > *目的：在不改变结构的前提下，调整具体的动作内容。*
    -   **动作替换**：重新筛选并替换指定动作。
        -   *规则*：将 `目标动作ID` 加入 `黑名单`。
        -   *规则*：调用 `[节点 4: 动作确认]` (输入: 黑名单, 原槽位) → 获取 `新候选动作`。
        -   *规则*：调用 `[节点 5: 动作实例化]` → 生成实例并替换。
    -   **动作删除**：移除动作并更新时长。
        -   *规则*：直接从序列移除，并更新 `课程总时长`。
    -   **器械切换**：基于器械变更触发动作替换。
        -   *规则*：用户指定某动作 `更换器械` (如: 哑铃 -> 徒手)。
        -   *规则*：更新 `槽位定义.可用器械` → 触发 `动作替换` 逻辑。

3.  **步骤 3: 策略与参数覆写**
    > *目的：调整训练的“质”与“量”。*
    -   **策略调整**：修改环节级策略并重算。
        -   *规则*：若修改 `负荷策略` (如: 推荐 -> 递增) 或 `循环模式` (如: 常规 -> 超级组)。
        -   *规则*：更新 `环节.基准参数` → 调用 `[节点 5: 动作实例化]` 重新计算该环节所有动作。
    -   **参数自定义**：响应用户对具体参数的修改。
        -   *规则*：若修改 `重量` / `次数` / `组数` / `时长`。
        -   **数值覆盖**：锁定用户修改值。
            -   *规则*：更新对应值，并标记 `用户自定义` = True。
        -   **联动计算**：处理组数变更的联动影响。
            -   *规则*：若修改 `组数`，需同步增加/减少 `组序列` 长度。

4.  **步骤 4: 序列与体验优化**
    > *目的：调整动作的执行顺序。*
    -   **动作排序**：响应拖拽排序指令。
        -   *规则*：响应前端拖拽指令，更新 `动作序列` 索引。
    -   **逻辑校验**：维护组合模式的完整性。
        -   *规则*：若排序导致 `超级组` 被拆散，需弹窗提示或自动解除超级组模式。

5.  **步骤 5: 强度校准**
    > *目的：基于用户主观反馈的整体强度调节。*
    -   **系数修正**：调整全局强度基准。
        -   *规则*：若 "太难" → `全局强度系数` - 0.05 (下限 0.5)。
        -   *规则*：若 "太易" → `全局强度系数` + 0.05 (上限 1.2)。
    -   **批量重算**：刷新非自定义动作的负荷。
        -   *规则*：对 `用户自定义` == False 的动作，调用 `[节点 5: 动作实例化]` 重算负荷。

### 3. 输出数据
- **确认后的课程对象** (流转至: 节点 7)：
    -   *推荐标签*：`课程类型`、`课程目标`、`目标部位`、`课程难度` (含用户修改)。
    -   *基础信息*：`课程时长` (含用户修改)。
    -   *环节配置*：`环节列表` (含用户增删)。
    -   *动作配置*：`实例化动作列表` (含用户自定义参数)。

### 4. 场景示例
> **场景**：用户觉得“哑铃卧推”肩膀不舒服，换成“俯卧撑”。
> - **输入**：指令=替换(哑铃卧推)。
> - **处理**：黑名单=[哑铃卧推]，重跑筛选 → 选中[俯卧撑]。
> - **输出**：更新后的动作列表，其中哑铃卧推变成了俯卧撑。

---

## 节点 7: 最终产出
> 定义：生成最终的课程详情对象，供前端展示和用户执行。
> > *业务导读*：打包出厂。把所有算好的数据整合起来，算出这节课的总卡路里和难度分，生成一句贴心的推荐语，准备上架。

### 1. 输入数据
- **确认后的课程对象** (来源: 节点 6)。
- **用户档案** (来源: 运动档案)：
    -   *基础数据*：`体重` (用于卡路里计算)。

### 2. 处理逻辑
1.  **步骤 1: 基础信息生成**
    > *目的：赋予课程唯一身份标识。*
    -   **ID生成**：创建唯一标识符。
        -   *规则*：生成 `课程ID` (UUID)。
    -   **元数据完善**：补充课程基础信息。
        -   *规则*：确认 `课程名称`、`课程介绍` (若为动态生成)。

2.  **步骤 2: 统计指标计算**
    > *目的：计算课程的能耗与强度指标，供用户参考。*
    -   **课程MET值**：计算平均代谢当量。
        -   *规则*：`Σ(动作.动作MET值 * 动作.总时长) / 课程总时长`。
    -   **预估卡路里**：计算总能量消耗。
        -   *规则*：`运动消耗` = `Σ(动作.动作MET值 * 动作.总时长)`。
        -   *规则*：`休息消耗` = `Σ(1.5 * 休息.总时长)` (假设休息MET=1.5)。
        -   *规则*：`总卡路里` = `(运动消耗 + 休息消耗) * 体重(kg) / 3600` (将秒转换为小时)。

3.  **步骤 3: 展示标签聚合**
    > *目的：提取课程的关键特征标签，用于列表展示和筛选。*
    -   **配件要求**：汇总所需器械。
        -   *规则*：提取并去重所有动作的 `动作器械`。
    -   **疼痛部位**：汇总潜在风险部位。
        -   *规则*：提取并去重所有动作的 `疼痛部位`。
    -   **冲击等级**：判定课程整体冲击性。
        -   *规则*：若包含任意 "高冲击" 动作 → "高冲击"；否则取最高等级。

4.  **步骤 4: 推荐理由生成**
    > *目的：生成一句个性化的推荐文案，告诉用户“为什么推荐这节课”。*
    -   **因子提取**：识别最显著的推荐依据。
        -   *规则*：获取 `动作确认` 阶段触发权值最高的 `推荐因子`。
    -   **文案映射**：生成用户友好的推荐语。
        -   *规则*：基于因子类型映射文案 (如 "新鲜奖励" → "为您精选了近期未练的新动作")。

5.  **步骤 5: 数据装配**
    > *目的：输出符合标准协议的最终数据对象。*
    -   **组装**：整合所有计算结果。
        -   *规则*：将上述计算结果与 `动作列表`、`环节列表` 整合。
    -   **格式化**：标准化输出结构。
        -   *规则*：确保字段类型与《课程属性》定义一致。

### 3. 输出数据
- **完整的课程详情对象** (输出给: 前端/执行端)：
    -   *基础信息*：`课程ID`、`课程名称`、`课程介绍`、`课程形态`。
    -   *推荐标签*：`课程类型`、`课程目标`、`目标部位`、`课程难度`、`课程时长`、`配件要求`、`疼痛部位`、`冲击等级`、`课程MET值`、`预估卡路里`。
    -   *课程素材*：`课程封面图`、`课程缩略图`、`预览视频`、`课程视频`。
    -   *环节配置*：`环节列表`。
    -   *其他*：`推荐理由`。

### 4. 场景示例
> **场景**：生成最终课程详情。
> - **输出**：
>   - **课程信息**：ID=CRS_Gen_001，标题="30分钟胸部增肌"
>   - **统计指标**：卡路里=150kcal，标签=["哑铃", "低冲击"]
>   - **推荐理由**："根据您的恢复状态推荐"

---

## 节点 8: 反馈闭环 (异步处理)
> 定义：课程执行结束后的数据反哺与算法进化。
> > *业务导读*：练完了不是结束，而是下一次更精准推荐的开始。
> *注：本节点逻辑详见《核心逻辑.md》- 第8层及《重量推荐逻辑.md》- 数据更新机制。*

### 1. 输入数据
- **执行数据**：`实际完成组数/重量/次数`、`实际时长`。
- **用户反馈**：`RPE评分`、`动作替换/删除记录`、`课程满意度`。

### 2. 处理逻辑
1.  **能力校准**：更新 `1RM` (基于最大负荷) 和 `记忆重量`。
2.  **偏好学习**：更新 `动作打分权重` (厌恶/收藏)。
3.  **状态更新**：扣除 `部位状态值` (疲劳消耗)。

---

## 需求池
> > *业务导读：未来版本规划的逻辑模块。*
1. **波浪负荷策略**：在平台期干预中引入波浪周期策略。
2. **修正系数逻辑**：基于计划阶段（如减载期）和生理状态（如疲劳/生理期）自动调整强度和容量系数。
3. **生理周期适配**：基于女性生理周期（月经期/卵泡期/排卵期/黄体期）自动调整训练强度、容量及动作禁忌。
4. **睡眠数据适配**：基于昨日睡眠时长修正疲劳恢复速率。
5. **风格策略适配**：基于用户偏好的训练风格（传统/多变/激进）调整课程结构与动作筛选逻辑。
6. **RPE相关逻辑**：基于RPE（自觉费力程度）的强度校准与反馈闭环。
7. **反馈闭环逻辑**：处理训练后的反馈数据（执行数据/替换/收藏），更新用户档案（1RM/偏好/平台期），实现算法进化。
7. **容量规划优化**：引入动态TUT (Time Under Tension) 基准。目前统一按45s估算，需针对力量训练（10-15s）和耐力训练（60s+）进行区分，以提高时长预估准确性。