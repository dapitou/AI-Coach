# 课程生成逻辑
> > *业务导读：生成单节训练课程的完整算法逻辑。*
> 定义：基于用户状态、训练目标和场景约束，动态生成个性化训练课程的核心算法。

## 核心架构
> > *业务导读：从用户输入到最终输出的决策流程图。*
> 架构：`用户输入` -> `课程确认` -> `环节确认` -> `动作确认` -> `动作实例化` -> `用户微调` -> `数据装配` -> `反馈闭环`

## 第一层：用户输入 (对应架构：输入层)
> 任务：收集生成课程所需的关键约束条件。
> > *业务导读：搞清楚今天练哪里（比如胸部），练多久，身体累不累，有没有受伤，确保生成的课是安全且符合当下的。*

### 课程参数设定（单节课程生成）
> > *业务导读：确定这节课练哪里、练多久，这是生成课程的基础输入。*
> **课程类型**：力量 | HIIT | 有氧 | 瑜伽 | 普拉提 | 拉伸 | 康复 [必填，单选，默认：力量]
> **目标部位**：全身｜胸部｜背部｜肩部｜手臂｜臀部｜腿部｜核心 [必填，多选，最多4项，默认：基于“部位疲劳状态”推荐]
> - **约束联动**：若 `课程类型` ∈ [HIIT, 有氧]，强制锁定为 "全身"。
> 来源：用户手动选择 (单课生成) 或 计划传入 (计划生成)。
> **单课时长**：20-60（min） [必填，滑动条，默认：档案“每日运动时长”]
> 来源：用户选择 或 计划继承。
> **单课环节**：热身 | 主训 | 放松 [必填，多选，默认：全选]

### 疲劳干预 (一级)
> > *业务导读：基于疲劳状态的安全拦截机制。*
> 引用：[4.1状态适配配置]
> **疲劳提示**：若用户选择的部位定性为[疲劳部位]（`部位状态值`处于`已力竭`或`疲劳中`状态），并提示推荐选择[恢复部位]（`已恢复`状态）。
> **策略降级**：若用户忽略提示坚持训练该部位，推荐将 课程`课程难度` 降2级（如 L3 -> L1），以保障安全。

### 档案校验与读取
> > *业务导读：确保用户档案数据满足生成要求。*
> 用途：为完成推荐生成，检查 [运动档案] 完整性，若缺失引导补全。
> **基础**：`性别`、`生日`、`身高`、`体重`、`BMI`、`主观疲劳度`
> **目标**：`主要目标`、`功能目标`、`目标体型`、`目标体重`
> **偏好**：`运动等级`、`每周训练日`、`每周运动频率`、`每日运动时长`、`疼痛部位`、`没有的器械`

### 计划上下文读取（计划课程生成）
> > *业务导读：当生成属于某个训练计划的课程时，从上层计划中继承条件参数。*
> 来源：[计划生成逻辑] (当前执行的`计划` -> `阶段` -> `单周循环模板` -> 当日`基础槽位`/`补充槽位`/`休息槽位`)。
> **继承参数**：
> - `上下文.课程类型` (对应 `课程.课程类型`)。
> - `上下文.侧重目标` (对应 `课程.目标部位` || `动作.动作模式` || `课程.课程目标`)。
> - `上下文.课程时长` (继承自 `计划.单课时长`)。
> - `上下文.环节列表` (继承自 `计划.单课环节`)。

## 第二层：课程确认 (对应架构：第4层 课程)
> 任务：确定课程维度的核心属性。
> > *业务导读：给这节课定调。是增肌课还是减脂课？难度是L1入门还是L5专业？确认课程基本属性。*

### 属性初始化
> > *业务导读：考虑用户输入和计划要求，确定这节课的最终目标和难度。*
> **课程目标**：
> - **优先级**：`用户输入` > `计划上下文` > `档案.功能目标`。
> - **计划上下文解析**：
>   - 若 `上下文.侧重维度` == "动作功能" → 取 `上下文.侧重目标`。
>   - 否则 → 取 `阶段.阶段目标`。
> **课程类型**：
> - **优先级**：`用户输入` > `上下文.课程类型`。
> **目标部位**：
> - **优先级**：`用户输入` > `智能推荐` > `计划上下文`。
> - **计划上下文解析**：
>   - 若 `上下文.侧重维度` == "部位" → 取 `上下文.侧重目标`。
>   - 若 `上下文.侧重维度` == "动作模式" → 映射部位(`上下文.侧重目标`)。
>   - 若 `上下文.侧重维度` == "动作功能" → 取 "全身" (默认)。
> **课程时长**：
> - **优先级**：`用户输入` > `档案.每日运动时长` > `上下文.课程时长`。
> **课程难度**：
> - `课程.课程难度` = `档案.运动等级`。


## 第三层：环节确认 (对应架构：第5层 环节)
> 任务：规划课程内部结构及各环节参数。
> > *业务导读：切分时间蛋糕（热身/主训/放松），再根据你的等级查表，确定要做几组、休息多久、强度多大。*

### 环节实例化与时长分配
> > *业务导读：按比例切分各环节时间，确保热身充分、放松到位、主训时间留足。*
> 引用：[1.3结构与组装配置]
> 逻辑：基于 课程`课程类型` 读取各环节的时长占比范围。
> **属性初始化**：
> - `环节.环节类型` = 热身 | 主训 | 放松。
> - `环节.环节名称` = `环节.环节类型` (默认)。
> - `环节.环节时长` = `课程.课程时长` × 分配比例。
> **热身**：按配置分配 (如 10% - 15%)。
> - 筛选标签：`动作.动作功能` ∈ [心肺, 激活, 协调, 平衡, 柔韧]。
> **主训**：按配置分配 (如 70% - 80%)。
> **放松**：按配置分配 (如 10% - 15%)。
> - 筛选标签：`动作.动作功能` ∈ [柔韧, 恢复, 体态, 呼吸]。

### 训练参数加载
> > *业务导读：根据你的等级，查表确定这节课的强度基准，比如做几组、休息多久。*
> 引用：[1.1策略矩阵配置]
> **基准参数加载**：
> - **查询键构建**：
>   - **配置上下文映射 (Configuration Context)** [优化]：
>     - *逻辑*：基于 `课程类型` 和 `课程目标` 共同决定策略键。
>     - *规则*：
>       - 若 `课程类型` 为强属性 (HIIT/瑜伽/有氧/普拉提/拉伸) → `策略键` = `课程类型`。
>       - 若 `课程类型` 为弱属性 (力量/康复) → `策略键` = `课程目标`。
>     - *示例*：
>       - 类型=HIIT, 目标=增肌 → 策略键="HIIT" (忽略增肌参数)。
>       - 类型=力量, 目标=增肌 → 策略键="增肌"。
>   - **等级维度**：`档案.运动等级`。
> - **赋值映射**：
>   - `环节.动作组数` = `策略.动作组数`。
>   - `环节.休息配置` = `策略.休息配置`。
>   - `环节.组间/轮间休息` = (`休息配置` == true ? `策略值` : 0)。
>   - `环节.训练强度` = `策略.训练强度`。
>   - `环节.循环模式` = `策略.循环模式`。
>   - `环节.负荷策略` = `策略.负荷策略`。
>   - `环节.难度策略` = `策略.难度策略` (应用[2.2 难度兼容策略]的概率分布)。
>   - `环节.动作节奏` = `策略.动作节奏`。
> **范式适配 (Paradigm Adaptation)** [新增]：
> 引用：[1.6 训练范式配置]
> - **逻辑**：根据 `课程类型` 映射 `训练范式`，加载默认参数覆盖基准值。
>   - **抗阻范式**：沿用标准逻辑 (关注组数/RPE/组间休息)。
>   - **间歇范式**：强制 `循环模式`="循环组", `负荷策略`="计时", `休息配置`=True (按工休比执行)。
>   - **流式范式**：强制 `动作组数`=1, `休息配置`=False (无间歇), `负荷策略`="计时"。
> **环节模板匹配**：
> **时间-容量自适应** [新增]：
> - **场景**：短时长课程 (≤30min) 遭遇高耗时策略 (如力量训练)。
> - **策略1 (休息压缩)**：基于目标差异化压缩 `组间休息`。
>   - **力量/爆发**：上限 120s (保神经恢复)。
>   - **增肌/塑形**：上限 60s (增代谢压力)。
>   - **减脂/心肺**：上限 45s (维持高心率)。
> - **策略2 (组数降级)**：若动作数量仍 < 3个，自动降低 `动作组数` (Min 2组)，优先保证动作多样性。
>
> 引用：[1.2课程环节模板配置]
> 适用范围：仅针对 [主训] 环节。热身/放松环节采用基于功能的自动填充逻辑（详见[动作确认]层）。
> - **匹配键构建**：
>   - 核心键 = `上下文.环节模板名称` || `课程.课程目标` || `课程.目标部位`。
>   - 等级键 = `档案.运动等级`。
>   - 性别键 = `档案.性别`。
> - **匹配逻辑**：**最佳匹配原则**。
>   - **L1 (精准)**：`模板键` == `[核心键]_[等级]_[性别]`。
>   - **L2 (降级)**：`模板键` == `[核心键]_[等级]`。
>   - **L3 (通用)**：`模板键` == `[核心键]`。
> - **赋值**：`环节.关联环节模板` = `匹配到的模板键`。

## 第四层：动作确认 (对应架构：第6层 容量与筛选)
> 任务：从动作库中筛选并填充具体动作。
> > *业务导读：像搭积木一样组装课程。先剔除不能做的，然后按环节需求一个个找最合适的动作填进去。*

### 1. 步骤 1: 安全过滤
> > *业务导读：建立绝对安全的动作白名单，剔除所有硬性风险。*
> - **输入**：完整动作库。
> - **逻辑**：
>   - 伤病规避：`动作.疼痛部位` ∩ `档案.疼痛部位` == Ø。
>   - 器械拦截：`动作.动作器械` ∩ `档案.没有的器械` == Ø。
>   - 冲击风控：若 `动作.冲击等级` == "高冲击"。
>     - 关节保护：`档案.疼痛部位` 包含 [膝盖, 脚踝] → 剔除。
>     - 体重保护：`档案.BMI` ≥ 28 && `档案.运动等级` < L5 → 剔除。
> - **输出**：`安全动作池`。

### 2. 步骤 2: 功能匹配
> > *业务导读：基于槽位定义进行宽泛召回，最大化候选池。*
> - **遍历**：对每个待填充的槽位 (Slot)：
>   - **热身/放松**：
>     - **功能匹配**：`动作.动作功能` ∈ 环节定义。
>     - **关联匹配**：优先匹配 `关联部位` ≈ `主训.目标部位`；不足时回退至 `通用全身` 或 `仅功能匹配`。
>   - **主训**：
>     - **目标匹配**：
>       - 单课：`动作.主要部位` ∈ `课程.目标部位`。
>       - 计划：`上下文.侧重维度` ≈ `动作属性`。
>     - **槽位匹配**：`动作属性` ⊆ `槽位定义`。
>     - **难度兼容**：`动作难度` ∈ `配置.难度兼容范围` (安全底线)。
>     - **功能过滤**：剔除低强度功能 (除非 `课程目标` 指定)。
>   - **产出**：`候选动作列表`。

### 3. 步骤 3: 难度定档
> > *业务导读：引入概率分布，打破单一难度的单调性。*
> - **概率抽样**：基于 `环节.难度策略` (概率分布) 抽取当前槽位的 `目标难度`。
> - *示例*：L3用户策略 -> 60%概率抽中L3, 20%抽中L2, 20%抽中L4。

### 4. 步骤 4: 推荐评分
> > *业务导读：将所有软性约束转化为分值，通过竞价机制选出最优解。*
> - **计算总分**：引用 `[3.1 推荐因子]`。
> - **加分项**：
>   - `难度契合奖励`：若 `动作难度` == `目标难度` (+30分)。
>   - `新鲜奖励`：近期未练 (+60分)。
>   - `匹配奖励`：完全符合骨架 (+100分)。
>   - `收藏奖励`：用户收藏 (+50分)。
> - **减分项**：
>   - `难度偏离惩罚`：若 `|动作难度 - 目标难度|` > 1 (-50分)。
>   - `厌倦惩罚`：近期频繁出现 (-80分)。
>   - `疲劳惩罚`：辅助肌处于疲劳状态 (-50分)。
> - **随机扰动** [新增]：
>   - *逻辑*：`最终得分` += `Random(0, 15)`。
>   - *目的*：引入随机性，避免同分动作排序固化，解决“每次生成都一样”的体验问题。
> - **一票否决**：若 `上下文.推荐降级` == True → 剔除 `冲击等级`="高冲击"。

### 5. 步骤 5: 竞价排序
> > *业务导读：基于总分择优录取，并处理无动作可用的极端情况。*
> - **排序**：按 `推荐总分` 降序排列。
> - **择优**：采用 **Top-K 随机策略** (从高分前3名中随机选)，避免局部最优。
> - **截取**：循环抽取直到满足 `槽位.目标数量`。
> - **兜底机制**：
>   - 若候选不足，按以下优先级逐步放宽约束，直到填满槽位：
>   - 1. **扩范围**：放宽`槽位匹配` (如 "水平推" -> "推类动作")。
>   - 2. **放宽难度**：打破难度兼容边界 (如 L1-L3 -> L1-L5)。
>   - 3. **改性质**：放宽`功能过滤` (如 "增肌" -> "耐力/塑形")。
>   - 4. **保骨架**：仅匹配`目标部位` (如 "胸部" -> 任意胸部动作)。
> - **缺口填充**：
>   - 若动作库彻底耗尽仍未填满槽位 → 增加已选动作的 `组数` (每缺1个动作，前序动作轮流 +1 组)，直到满足时长预算。
>   - **熔断限制**：单个动作最大组数 ≤ 6。
>   - **降维填充**：若达到组数上限仍有缺口 → 引入 `辅助部位` 动作 (如练腿不足补核心) 或 `通用体能` 动作 (如开合跳)。

### 6. 步骤 6: 序列编排
> > *业务导读：微调动作顺序，优化实际执行体验。*
> - **体能分配**：排序(`动作.构造`, 复合 > 孤立)。
> - **硬件体验**：排序(`动作.力臂位置`)，使相邻动作挡位接近。
> - **核心后置**：若 `动作.主要部位` == "核心" && `课程.目标部位` != "核心" → 移至队尾。
> - **流式优化**：若为流式范式 → 排序(`体位变换成本`)，确保体式平滑过渡 (如: 站姿->下犬->俯卧)。
> - **强度波动**：若为间歇范式 → 排序(`动作强度`)，呈波浪状分布 (高-低-高-低)。
> - **流畅度优化**：分组(`动作.器械`, `动作.体位`)。
> - **超级组配对**：若 `循环模式` == "超级组" → 配对(`主动肌`, `拮抗肌`)。
> - **安全风控**：若 `连续高冲击动作` > 2 → 推荐插入 `低冲击动作`。

## 第五层：动作实例化 (对应架构：第7层 动作实例化)
> 任务：计算每个动作的具体执行参数（重量/次数/组数）。
> > *业务导读：给每个动作算具体的重量和次数。新动作靠推算，旧动作看历史，组间还能根据你累不累动态调整。*
> **处理机制**：**原子化处理**。本层逻辑针对环节内的每一个动作单独执行，因此完美支持同一环节内混合存在“计次力量动作”和“计时有氧动作”。

### 执行参数计算
> > *业务导读：根据你的能力算出合适的重量（负荷计算）；根据强度决定做几次或做多久（次数/时长）；安排每一组的变化（组间策略）。*

#### 步骤一：计算模式判定
> **逻辑**：基于 **训练意图** (环节策略) 和 **动作属性** (固有维度) 决定计算流。
> **机制**：逐个动作判定，支持混合编排。
> **判定规则**：
> 1. **容量优先模式**：
>    - 条件：`环节.负荷策略` == "计时" || `动作.默认计量维度` == "计时" || `动作.力量模组` == "否"。
>    - *特征*：优先确定做多久/做多少个，重量是次要或固定的。
> 2. **负荷优先模式**：
>    - 条件：上述不满足 (即：有电机 且 非计时 且 策略为推荐/递增等)。
>    - *特征*：优先确定做多重，次数是根据重量反推的。

#### 步骤二：参数计算 (分模式)

**模式 A：负荷优先**
> **适用场景**：传统力量训练 (增肌/力量)。
> **计算流**：`强度` -> `重量` -> `次数`。
> 1. **定重量 (Weight)**：
>    - **输入**：`意图强度` (如 85%)。
>    - **计算**：调用 [重量推荐逻辑.md]。
>      - `推荐重量` = `用户.1RM` × `意图强度`。
>      - *风控*：应用安全熔断与边界限制。
> 2. **定次数**：
>    - **理论最大次数**：查表(`RM表`, `意图强度`)。
>    - `推荐次数` = `理论最大次数`。
> 3. **定组间策略**：
>    - 应用 [2.1负荷与组间策略配置] (如递增/恒定)。

**模式 B：容量优先**
> **适用场景**：自重训练、HIIT、有氧、功能性训练。
> **计算流**：`强度` -> `容量` -> `重量(适配)`。
> 1. **定容量**：
>    - **计时类** (策略="计时" 或 维度="计时")：
>      - `推荐时长` = 查表(`强度表`, `意图强度`)。
>      - `推荐次数` = 0。
>    - **计次类** (其他)：
>      - `推荐次数` = 查表(`强度表`, `意图强度`)。
>      - `推荐时长` = 0。
> 2. **定重量**：
>    - **无电机**：`推荐重量` = 0。
>    - **有电机** (如HIIT划船)：
>      - 调用 [重量推荐逻辑.md] - `2.5 基于时长的负荷推荐`。
>      - `推荐重量` = `用户.1RM` × `适配RM%` × `意图强度`。
> 3. **定组间策略**：
>    - 通常为"恒定"或"计时"。

#### 步骤三：单组耗时估算
> **逻辑**：用于计算课程总时长。
> - **计次动作**：`单组时长` = `推荐次数` × `动作.单次时长`。
> - **计时动作**：`单组时长` = `推荐时长`。
> - **单边修正**：
>   - 若 `动作.单边独立性` == true → `单组时长` = `单组时长` × 2 + `换边休息(5s)`。

#### 步骤四：组间策略序列生成
> **逻辑**：决定每一组的重量/次数是否变化。
> **引用**：[2.1负荷与组间策略配置]
> - **输入**：`环节.负荷策略`。
> - **适配逻辑**：
>   - **模式 A (负荷优先)**：完整应用策略。
>     - *重量* = `基准重量` × `负荷系数`。
>     - *次数* = `基准次数` + `次数增量`。
>   - **模式 B (容量优先)**：将策略映射到容量维度 (实现同动作内的强度变化)。
>     - *容量* = `基准容量` × `负荷系数`。
>     - *重量* = 保持不变 (或随容量适配)。
> - **输出**：生成每组的具体参数序列。
>   - *示例 (递增)*：力量动作(重量递增 85%->100%)；有氧动作(时长递增 85%->100%)。

## 第六层：用户微调 (对应架构：交互层)
> 任务：赋予用户最终决定权。
> > *业务导读：不喜欢的动作可以换，觉得太难可以调，把最终决定权交给你。*

> **动作替换**：点击动作 -> 选择替换 [选填，交互] -> 解决用户不喜欢特定动作的问题。
> **参数调整**：修改组数/重量/次数 [选填，数字输入，默认：当前值] -> 调整训练负荷，系统记录并学习。
> **难度调整**：降低难度 | 提升难度 [选填，单选] -> 整体调整课程难度系数，适配当日状态。
> **环节调整**：排序 | 删除 [选填，交互] -> 自定义课程结构。

## 第七层：数据装配 (对应架构：输出层)
> 任务：实例化为标准的课程数据对象。
> 目标：确保数据与《课程属性》定义完美对应。
> > *业务导读：数据格式化与打包，准备输出给前端。*


### 字段填充
> > *业务导读：把算好的数据打包成前端能看懂的格式，算出卡路里和难度分。*
> **基础信息**：生成 `课程ID`、`课程名称`、`课程介绍`。
> **推荐理由** [新增]：生成一句话推荐语。
>   - *逻辑*：基于触发的最高权重奖励因子生成。
>   - *示例*："根据您的疲劳状态，今日为您安排了低强度的恢复训练" 或 "针对您薄弱的[上胸]进行了强化安排"。
> **数值计算**：
> - **预估卡路里**：`Σ(动作.MET × 动作.时长) + Σ(休息.MET[1.5] × 休息.时长)) × 体重`。
> - **课程MET值**：`Σ(动作.MET × 动作.时长) / 总动作时长`。
> **标签聚合**：聚合 `配件要求`、`冲击等级`、`疼痛部位`。
### 输出
> 结果：完整的 JSON 课程对象。

## 需求池
> > *业务导读：未来版本规划的逻辑模块。*
1. **波浪负荷策略**：在平台期干预中引入波浪周期策略。
2. **修正系数逻辑**：基于计划阶段（如减载期）和生理状态（如疲劳/生理期）自动调整强度和容量系数。
3. **生理周期适配**：基于女性生理周期（月经期/卵泡期/排卵期/黄体期）自动调整训练强度、容量及动作禁忌。
4. **风格策略适配**：基于用户偏好的训练风格（传统/多变/激进）调整课程结构与动作筛选逻辑。
5. **RPE相关逻辑**：基于RPE（自觉费力程度）的强度校准与反馈闭环。
6. **反馈闭环逻辑**：基于训练数据反哺算法（强度校准/偏好学习/平台期识别），实现自我进化。
