# 课程生成逻辑
> > *业务导读：生成单节训练课程的完整算法逻辑。*
> 定义：基于用户状态、训练目标和场景约束，动态生成个性化训练课程的核心算法。

## 核心架构
> > *业务导读：从用户输入到最终输出的决策流程图。*
> 架构：`用户输入` -> `课程确认` -> `环节确认` -> `动作确认` -> `动作实例化` -> `用户微调` -> `数据装配` -> `反馈闭环`

## 第一层：用户输入 (对应架构：输入层)
> 任务：收集生成课程所需的关键约束条件。
> > *业务导读：搞清楚今天练哪里（比如胸部），练多久，身体累不累，有没有受伤，确保生成的课是安全且符合当下的。*

### 课程参数设定
> > *业务导读：确定这节课练哪里、练多久，这是生成课程的基础输入。*
> **目标部位**：全身｜胸部｜背部｜肩部｜手臂｜臀部｜腿部｜核心 [必填，多选，最多4项，默认：基于“部位疲劳状态”推荐]
> 来源：用户手动选择 (单课生成) 或 计划传入 (计划生成)。
> **单课时长**：20-60（min） [必填，滑动条，默认：档案“每日运动时长”]
> 来源：用户选择 或 计划继承。
> **单课环节**：热身 | 主训 | 放松 [必填，多选，默认：全选]

### 疲劳干预 (一级)
> > *业务导读：基于疲劳状态的安全拦截机制。*
> 引用：[4.1状态适配配置]
> **疲劳提示**：若用户选择的部位定性为[疲劳部位]（`部位状态值`处于`已力竭`或`疲劳中`状态），并提示推荐选择[恢复部位]（`已恢复`状态）。
> **策略降级**：若用户忽略提示坚持训练该部位，强制将 课程`课程难度` 降2级（如 L3 -> L1），以保障安全。

### 档案校验与读取
> > *业务导读：确保用户档案数据满足生成要求。*
> 用途：为完成推荐生成，检查 [运动档案] 完整性，若缺失引导补全。
> **基础**：`性别`、`生日`、`身高`、`体重`、`BMI`、、、`每日运动时长`、`喜欢的训练风格`、`主观疲劳度`
> **目标**：`主要目标`、`功能目标`、`目标体型`、`目标体重`
> **偏好**：`运动等级`、`每周训练日`、`每周运动频率`、`每周运动时长`、`喜欢的训练风格`、`疼痛部位`、`没有的器械`

### 计划上下文读取（计划课程生成）
> > *业务导读：当生成属于某个训练计划的课程时，从上层计划中继承约束条件参数。*
> 来源：[计划生成逻辑] (当前执行的`计划` -> `阶段` -> `单周循环模板` -> 当日`基础槽位`/`填充槽位`/`休息槽位`)。
> **继承参数**：
> - 上下文`课程类型` (对应 课程`课程类型`)。
> - 上下文`侧重目标` (对应 课程`目标部位` 或 动作`动作模式`)。
> - 上下文`课程时长` (继承自 计划`单课时长`)。
> - 上下文`环节列表` (继承自 计划`单课环节`)。
> - 上下文`强度系数` (继承自 阶段`强度修正系数`)。
> - 上下文`容量系数` (继承自 阶段`容量修正系数`)。

## 第二层：课程确认 (对应架构：第4层 课程)
> 任务：确定课程维度的核心属性。
> > *业务导读：给这节课定调。是增肌课还是减脂课？难度是L1入门还是L5专业？确认课程基本属性。*

### 属性初始化
> > *业务导读：考虑用户输入和计划要求，确定这节课的最终目标和难度。*
> **课程目标**：
> - 单课生成：课程`课程目标` = 档案`功能目标`。
> - 计划生成：课程`课程目标` = 阶段`阶段目标`。
> **课程类型**：
> - 单课生成：课程`课程类型` = 用户输入`课程类型`。
> - 计划生成：课程`课程类型` = 上下文`课程类型`。
> **目标部位**：
> - 单课生成：课程`目标部位` = 用户输入`目标部位`。
> - 计划生成：课程`目标部位` = 上下文`侧重目标` (若为`动作模式`则映射为解剖部位)。
> **课程时长**：
> - 单课生成：课程`课程时长` = 用户输入`运动时长`。
> - 计划生成：课程`课程时长` = 上下文`课程时长`。
> **课程难度**：
> - 课程`课程难度` = 档案`运动等级`。


## 第三层：环节确认 (对应架构：第5层 环节)
> 任务：规划课程内部结构及各环节参数。
> > *业务导读：切分时间蛋糕（热身/主训/放松），再根据你的等级查表，确定要做几组、休息多久、强度多大。*

### 环节实例化与时长分配
> > *业务导读：按比例切分各环节时间，确保热身充分、放松到位、主训时间留足。*
> 引用：[1.3结构与组装配置]
> 逻辑：基于 课程`课程类型` 读取各环节的时长占比范围。
> **属性初始化**：
> - 环节`环节类型` = 热身 | 主训 | 放松 (依据结构定义)。
> - 环节`环节名称` = 环节`环节类型` (默认)。
> - 环节`环节时长` = 课程`课程时长` × 分配比例。
> **热身**：按配置分配 (如 10% - 15%)。
> - 筛选标签：动作`动作功能` ∈ [心肺, 激活, 协调, 平衡, 柔韧]。
> **主训**：按配置分配 (如 70% - 80%)。
> **放松**：按配置分配 (如 10% - 15%)。
> - 筛选标签：动作`动作功能` ∈ [柔韧, 恢复, 体态, 呼吸]。

### 训练参数加载
> > *业务导读：根据你的等级，查表确定这节课的强度基准，比如做几组、休息多久。*
> 引用：[1.1策略矩阵配置]
> **基准参数加载**：
> - **查询键构建**：
>   - 目标维度：
>     - 单课生成：档案`功能目标` 
>     - 计划生成：阶段`阶段目标`
>   - 等级维度：统一取 档案`运动等级`。
> - **赋值映射**：
>   - 环节`动作组数` = 策略`动作组数`。
>   - 环节`休息配置` = 策略`休息配置` (是/否)。
>   - 环节`组间休息`/`轮间休息` = 若`休息配置`为"是"，则取策略值，否则为0。
>   - 环节`训练强度` = 策略`训练强度`。
>   - 环节`目标RPE` = 策略`目标RPE`。
>   - 环节`循环模式` = 策略`循环模式`。
>   - 环节`负荷策略` = 策略`负荷策略`。
>   - 环节`难度策略` = 策略`难度策略`。
>   - 环节`动作节奏` = 策略`动作节奏`。
> **环节模板匹配**：
> 引用：[1.2课程环节模板配置]
> 适用范围：仅针对 [主训] 环节。热身/放松环节采用基于功能的自动填充逻辑（详见[动作确认]层）。
> - **匹配键构建**：
>   - 核心键 = 上下文`环节模板名称`|| 课程`课程目标` || 课程`目标部位` 。
>   - 等级键 = 档案`运动等级`。
>   - 性别键 = 档案`性别`。
> - **匹配逻辑**：**最佳匹配原则**。
>   - **L1 (精准)**：查找 `模板键` == `[核心键]_[等级]_[性别]` (如 "臀部_L3_女")。
>   - **L2 (降级)**：查找 `模板键` == `[核心键]_[等级]` (如 "胸部_L1")。
>   - **L3 (通用)**：查找 `模板键` == `[核心键]` (如 "推力日")。
> - **赋值**：环节`关联环节模板` = 匹配到的模板键 (Key)。

### 参数修正
> > *业务导读：根据你的疲劳度、生理期和风格偏好，微调训练参数。*
> 引用：[4.1状态适配配置]
> 引用：[3.2风格策略配置]
> **修正对象**：本层实例化的 `环节` 对象属性（主要是 `训练强度`、`动作组数`、`难度策略`）。
> **修正逻辑**：按以下顺序执行计算，系数采用乘法叠加。
>
> **1. 状态修正 (生理/疲劳)**：
> - 来源：[4.1状态适配配置]
> - 逻辑：
>   - 获取 `疲劳系数`：根据 `部位状态值` 查表 (如 "疲劳中" -> 强度0.8/容量0.8)。
>   - 获取 `生理系数`：
>     - 若 档案`性别` == "男"：系数恒为 1.0。
>     - 若 档案`性别` == "女"：根据 档案`生理周期` 查表 (如 "月经期" -> 强度0.6/容量0.5)。
> - 执行：
>   - `环节.训练强度` = `环节.训练强度` × `疲劳系数.强度` × `生理系数.强度`。
>   - `环节.动作组数` = `环节.动作组数` × `疲劳系数.容量` × `生理系数.容量` (结果四舍五入取整，下限为1)。
>
> **2. 周期修正 (计划上下文)**：
> - 条件：仅在 [计划生成] 模式下触发。
> - 来源：上下文`强度系数`、上下文`容量系数` (来自阶段定义)。
> - 执行：
>   - `环节.训练强度` = `环节.训练强度` × `上下文.强度系数`。
>   - `环节.动作组数` = `环节.动作组数` × `上下文.容量系数` (结果四舍五入取整，下限为1)。
>
> **3. 风格修正 (策略覆盖)**：
> - 来源：[3.2风格策略配置]
> - 逻辑：根据 档案`喜欢的训练风格` 匹配配置项。
> - 执行：若存在 `策略覆盖` 字段，直接覆盖环节对应属性。
>   - 例：若风格="激进型"，配置定义 `难度策略`="进阶"，则强制 `环节.难度策略` = "进阶"。

## 第四层：动作确认 (对应架构：第6层 容量与筛选)
> 任务：从动作库中筛选并填充具体动作。
> > *业务导读：从动作库里捞动作。先把不能做的（受伤/没器械）剔除，再按新鲜感和匹配度打分，最后选出最合适的动作填进去。*

### 智能筛选
> > *业务导读：从动作库里挑动作，先剔除不能做的，再选效果好的和新鲜的。*
> **初筛**：
> - 主训：选取 动作`主要部位` == 课程`目标部位` (或 动作`动作模式` 匹配) 的动作。
> - 热身/放松：选取 动作`动作功能` 符合环节定义，且优先匹配主训`动作模式` (参考 [数据映射].`动作模式-热身功能映射`)。
> **剔除 (硬规则)**：
> - 伤病规避：动作`疼痛部位` ∩ 档案`疼痛部位` == Ø (无交集)。
> - 器械拦截：动作`动作器械` ∩ 档案`没有的器械` == Ø (无交集)。
> **打分 (软规则)**：
> 引用：[3.1推荐影响因子配置]后续会大量拓展影响因子。
> 逻辑：初始分=0，满足条件累加分值，最终按总分排序。
> - **加分项**：核心匹配奖励、功能热身奖励(基于数据映射)、风格契合奖励、难度适宜奖励、新鲜奖励、探索奖励(新动作)、高效奖励、连贯性奖励。
> - **扣分项**：疲劳惩罚、厌倦惩罚、难度偏离惩罚、安全风控惩罚 (基于 动作`冲击等级` vs 档案`BMI`)。
> - **互斥逻辑**：若已选动作列表中存在同名动作，后续同名变体强制扣分 (-500)。

### 环节组装
> > *业务导读：把选出来的动作填进时间槽里，先做难的复合动作，再做简单的孤立动作。*
#### 热身/放松
> > *业务导读：根据时长自动填充热身和放松动作。*
> 1. **算数量**：根据环节时长，估算需要几个动作（热身约30s/个，放松约30s/个）。
> 2. **选动作**：
>    - **热身**：优先选择与主训`动作模式`对应的激活/柔韧动作 (如主训蹲，热身选髋关节激活)。若不足，补充通用心肺动作 (如开合跳)。
>    - **放松**：优先选择与主训`主要部位`对应的静态拉伸动作。
>    - **策略**：从评分最高的 Top 5 动作池中，按权重随机抽取目标数量的动作。

#### 主训环节 (通用)
> 引用：[1.2课程环节模板配置]
> > *业务导读：选定配方（模板），算好量（容量），填动作（填充），多退少补（平衡），最后排排坐（排序）。*
> - **步骤1：加载模板 (定配方)**：
>   - **逻辑**：根据 `关联环节模板` 读取动作配比 (如：核心动作60% + 辅助动作40%)。
>   - **兜底**：若无匹配，使用 `通用` 模板。
> - **步骤2：容量规划 (算总量)**：
>   - **总组数**：`环节时长` / `单组耗时` (约60s)。
>   - **动作数**：`总组数` / 环节`动作组数`。
> - **步骤3：动作填充 (选动作)**：
>   - **分配**：按模板占比将 `动作数` 分配给各槽位。
>   - **抽取**：在符合槽位定义的动作池中，按 [3.1推荐影响因子] 得分加权随机抽取。
> - **步骤4：动态平衡 (多退少补)**：
>   - **补漏**：若某槽位动作不足，扩大筛选范围 (如：从`水平推` -> `上肢推`)。
>   - **裁剪**：若预估时长超标，优先剔除辅助动作，其次减少核心动作组数。
> - **步骤5：排序优化 (整理队形)**：
>    > *业务导读：把复合动作排前面（先难后易）；把同器械同姿势的排一起（少折腾）；超级组要对练（高效）；别连续蹦跳（防受伤）。*
>    - **规则1：能量管理**：
>      - **逻辑**：按 动作`动作构造` 降序排列 (复合动作 > 孤立动作)。
>    - **规则2：流畅度优化**：
>      - **逻辑**：在满足规则1的前提下，优先聚合相同 动作`动作器械` 和 动作`动作体位` 的动作。
>      - **算法**：贪心策略，寻找属性切换成本最低的下一动作。
>    - **规则3：超级组配对** (仅当 环节`循环模式` == 超级组)：
>      - **逻辑**：基于 [数据映射].`主动肌-拮抗肌关系表`，将动作两两配对。
>      - **约束**：若用户器械不足 (如只有一对哑铃)，禁止配对同器械动作。
>    - **规则4：安全风控**：
>      - **逻辑**：检测连续高冲击动作序列。
>      - **修正**：若连续 > 2个高冲击动作，强制插入低冲击动作或打散。

## 第五层：动作实例化 (对应架构：第7层 动作实例化)
> 任务：计算每个动作的具体执行参数（重量/次数/组数）。
> > *业务导读：给每个动作算具体的重量和次数。新动作靠推算，旧动作看历史，组间还能根据你累不累动态调整。*
> **处理机制**：**原子化处理**。本层逻辑针对环节内的每一个动作单独执行，因此完美支持同一环节内混合存在“计次力量动作”和“计时有氧动作”。

### 执行参数计算
> > *业务导读：根据你的能力算出合适的重量（负荷计算）；根据强度决定做几次或做多久（次数/时长）；安排每一组的变化（组间策略）。*

#### 步骤一：计算模式判定 (Mode Determination)
> **逻辑**：基于 **训练意图** (环节策略) 和 **动作属性** (固有维度) 决定计算流。
> **机制**：逐个动作判定，支持混合编排。
> **判定规则**：
> 1. **容量优先模式 (Volume-First)**：
>    - 条件：环节`负荷策略` == "计时" OR 动作`默认计量维度` == "计时" OR 动作`力量模组` == "否"。
>    - *特征*：优先确定做多久/做多少个，重量是次要或固定的。
> 2. **负荷优先模式 (Load-First)**：
>    - 条件：上述不满足 (即：有电机 且 非计时 且 策略为推荐/递增等)。
>    - *特征*：优先确定做多重，次数是根据重量反推的。

#### 步骤二：参数计算 (分模式)

**模式 A：负荷优先 (Load-First)**
> **适用场景**：传统力量训练 (增肌/力量)。
> **计算流**：`强度` -> `重量` -> `次数`。
> 1. **定重量 (Weight)**：
>    - **输入**：`意图强度` (来自环节配置，如 85%)。
>    - **计算**：调用 [重量推荐逻辑.md]。
>      - `推荐重量` = `用户1RM` (历史或推算) × `意图强度` (含遗忘曲线/冷启动推算)。
>      - *风控*：应用安全熔断与边界限制。
> 2. **定次数 (Reps)**：
>    - **理论最大次数**：查阅 [RM百分比表] (如 85% -> 6RM)。
>    - **RPE修正**：`推荐次数` = `理论最大次数` - (10 - `目标RPE`)。
>      - *示例*：强度85%(6RM)，目标RPE 8 (保留2次) -> 推荐做 4 次。
>      - *兜底*：若计算结果 < 1，强制设为 1。
> 3. **定组间策略**：
>    - 应用 [2.1负荷与组间策略配置] (如递增/恒定)。

**模式 B：容量优先 (Volume-First)**
> **适用场景**：自重训练、HIIT、有氧、功能性训练。
> **计算流**：`强度` -> `容量` -> `重量(适配)`。
> 1. **定容量 (Volume)**：
>    - **计时类** (策略="计时" 或 维度="计时")：
>      - `推荐时长` = 查表([强度指标映射], `意图强度`) -> 如 L3=45s。
>      - `推荐次数` = 0。
>    - **计次类** (其他)：
>      - `推荐次数` = 查表([强度指标映射], `意图强度`) -> 如 L3=15次。
>      - `推荐时长` = 0。
> 2. **定重量 (Weight)**：
>    - **无电机**：`推荐重量` = 0 (前端展示"自重")。
>    - **有电机** (如HIIT划船)：
>      - 调用 [重量推荐逻辑.md] - `2.5 基于时长的负荷推荐`。
>      - `推荐重量` = `用户1RM` × `适配RM%(基于容量)` × `意图强度`。
> 3. **定组间策略**：
>    - 通常为"恒定"或"计时"。

#### 步骤三：单组耗时估算
> **逻辑**：用于计算课程总时长。
> - **计次动作**：`单组时长` = `推荐次数` × `单次动作时长` (来自动作属性)。
> - **计时动作**：`单组时长` = `推荐时长`。
> - **单边修正**：若 动作`单边独立性`="是"，则 `单组时长` = `单组时长` × 2 + `换边休息(5s)`。

#### 步骤四：组间策略序列生成
> **逻辑**：决定每一组的重量/次数是否变化。
> **引用**：[2.1负荷与组间策略配置]
> - **输入**：环节`负荷策略` (如 "递增" / "恒定")。
> - **适配逻辑**：
>   - **模式 A (负荷优先)**：完整应用策略。
>     - *重量* = 基准重量 × `负荷系数`。
>     - *次数* = 基准次数 + `次数增量`。
>   - **模式 B (容量优先)**：将策略映射到容量维度 (实现同动作内的强度变化)。
>     - *容量 (时长/次数)* = 基准容量 × `负荷系数`。
>     - *重量* = 保持不变 (或随容量适配)。
> - **输出**：生成每组的具体参数序列。
>   - *示例 (递增)*：力量动作(重量递增 85%->100%)；有氧动作(时长递增 85%->100%)。

## 第六层：用户微调 (对应架构：交互层)
> 任务：赋予用户最终决定权。
> > *业务导读：不喜欢的动作可以换，觉得太难可以调，把最终决定权交给你。*

> **动作替换**：点击动作 -> 选择替换 [选填，交互] -> 解决用户不喜欢特定动作的问题。
> **参数调整**：修改组数/重量/次数 [选填，数字输入，默认：当前值] -> 调整训练负荷，系统记录并学习。
> **难度调整**：降低难度 | 提升难度 [选填，单选] -> 整体调整课程难度系数，适配当日状态。
> **环节调整**：排序 | 删除 [选填，交互] -> 自定义课程结构。

## 第七层：数据装配 (对应架构：输出层)
> 任务：实例化为标准的课程数据对象。
> 目标：确保数据与《课程属性》定义完美对应。
> > *业务导读：数据格式化与打包，准备输出给前端。*


### 字段填充
> > *业务导读：把算好的数据打包成前端能看懂的格式，算出卡路里和难度分。*
> **基础信息**：生成 `课程ID`、`课程名称`、`课程介绍`。
> **数值计算**：计算 `预估卡路里`、`课程MET值`、`预估RPE`。
> **标签聚合**：聚合 `配件要求`、`冲击等级`、`疼痛部位`。
### 输出
> 结果：完整的 JSON 课程对象。

## 第八层：反馈闭环 (对应架构：数据层)
> 任务：基于训练数据反哺算法，实现自我进化。
> > *业务导读：练完之后，根据你的反馈（累不累、喜不喜欢）来调整下一次的推荐，越练越懂你。*

### 强度校准
> > *业务导读：根据RPE反馈调整用户的力量基准。*
> > *业务导读：根据你练完后的反馈（累不累），调整下一次的强度基准。*
> 引用：[4.2反馈与自适应配置]
> 逻辑：若 |`用户反馈RPE` - 课程`预估RPE`| > 配置.`RPE偏差阈值` -> 调整该用户该部位的 档案`1RM` 或 `强度修正系数`。
> **平台期识别**：
> - 条件：(连续 N 次训练 动作`推荐重量` 未提升) ≥ 配置.`平台期判定次数` && (课程`完成度` > 配置.`有效训练完成度`)。
> - 决策：
>   1. 标记该用户该部位进入“平台期”。
>   2. 下次生成课程时，强制切换 `负荷策略` (如：从“推荐”切换为“波浪”或“递减”)，或建议“减载周”。

### 偏好学习
> > *业务导读：根据用户的替换和收藏行为优化推荐偏好。*
> > *业务导读：记住你喜欢和讨厌的动作，下次推荐时投其所好。*
> 引用：[4.2反馈与自适应配置]
> 逻辑：若某动作被用户 **主动替换** 次数 ≥ 配置.`厌恶判定次数` -> 加入“冷宫名单”（应用 [3.1推荐影响因子配置].`冷宫惩罚`）。
> 逻辑：若某动作被用户 **收藏** -> 应用 [3.1推荐影响因子配置].`收藏奖励`。
