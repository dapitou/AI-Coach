<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>人脸追踪 - 鼻尖碰球爆炸游戏 (文字修复版)</title>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        /* 基础样式保持不变 */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #000; overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        .container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
        }
        /* 【关键】CSS 这里的 scaleX(-1) 保持不变，
           用于保证画面是镜像的，符合操作直觉。
        */
        video, canvas {
            position: absolute; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
        }
        video { z-index: 1; opacity: 0; transition: opacity 0.5s; }
        canvas { z-index: 2; }

        /* UI 组件样式 */
        .center-msg {
            position: absolute; z-index: 10; top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            color: rgba(255, 255, 255, 0.9); background: rgba(0,0,0,0.6);
            padding: 20px 40px; border-radius: 12px; backdrop-filter: blur(5px);
            font-size: 1.5rem; letter-spacing: 2px; border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
        }
        .score-board {
            position: absolute; top: 30px; right: 40px; z-index: 30;
            color: #FFD700; /* 金色分数 */
            font-size: 32px; font-weight: 800;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3); padding: 10px 20px;
            border-radius: 10px; border: 1px solid rgba(255,215,0,0.3);
        }
        .control-panel {
            position: absolute; bottom: 40px; left: 40px; z-index: 20;
            background: rgba(20, 20, 20, 0.6); padding: 10px 20px;
            border-radius: 30px; backdrop-filter: blur(10px);
            display: flex; align-items: center; gap: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        /* 开关样式 */
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 22px; width: 22px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #34c759; }
        input:checked + .slider:before { transform: translateX(22px); }
        .label-text { color: white; font-size: 14px; }
    </style>
</head>
<body>

    <div class="container">
        <div class="score-board">Score: <span id="scoreVal">0</span></div>
        <div class="center-msg" id="messageBox">请开启摄像头<br><span style="font-size:0.8em">越大越好撞，分越高！</span></div>
        <video id="inputVideo" playsinline></video>
        <canvas id="outputCanvas"></canvas>
    </div>

    <div class="control-panel">
        <label class="switch">
            <input type="checkbox" id="toggleBtn">
            <span class="slider"></span>
        </label>
        <span class="label-text">开始游戏</span>
    </div>

    <script>
        // --- 1. 全局变量与设置 ---
        const videoElement = document.getElementById('inputVideo');
        const canvasElement = document.getElementById('outputCanvas');
        const ctx = canvasElement.getContext('2d');
        const toggleBtn = document.getElementById('toggleBtn');
        const messageBox = document.getElementById('messageBox');
        const scoreSpan = document.getElementById('scoreVal');

        let faceMesh, camera;
        let isRunning = false;
        let nosePosition = null; 
        const NOSE_RADIUS = 15; 
        let score = 0;

        const EXPLOSION_COLORS = ['#FFD700', '#FF4500', '#00BFFF', '#FF1493', '#7FFF00', '#9400D3'];

        // 对象管理器
        let tailParticles = [];      
        let fallingBalls = [];       
        let explosionParticles = []; 
        let floatingTexts = [];

        // 工具函数：计算距离
        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }

        // --- 2. 类定义区域 ---

        // 【核心修复】漂浮文字类 (+分数特效)
        class FloatingText {
            constructor(x, y, points) {
                this.x = x;
                this.y = y;
                this.text = "+" + points;
                this.life = 1.0; 
                this.vy = -3; 
            }

            update() {
                this.y += this.vy;
                this.life -= 0.02; 
            }

            draw(context) {
                if (this.life <= 0) return;
                
                // --- 修复镜像问题的关键代码块 ---
                context.save(); // 1. 保存当前画布状态

                // 2. 将画布的原点移动到文字需要显示的位置
                context.translate(this.x, this.y);

                // 3. 在JS内部进行一次水平翻转。
                // CSS已经翻转了一次(-1)，这里再翻转一次(-1)，负负得正，文字就正常了。
                context.scale(-1, 1); 

                context.font = "bold 28px Arial";
                context.textAlign = "center"; 
                context.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                context.strokeStyle = `rgba(0, 0, 0, ${this.life * 0.5})`;
                context.lineWidth = 3;
                
                // 4. 在新的原点 (0,0) 绘制文字
                context.strokeText(this.text, 0, 0);
                context.fillText(this.text, 0, 0);

                context.restore(); // 5. 恢复画布状态，避免影响后续的绘制
                // --- 修复结束 ---
            }
        }

        // 通用粒子类 (尾巴和爆炸)
        class Particle {
            constructor(x, y, color, speedMultiplier = 1.0) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 5 * speedMultiplier;
                this.vy = (Math.random() - 0.5) * 5 * speedMultiplier;
                this.life = 1.0; 
                this.decay = (Math.random() * 0.02 + 0.01) * speedMultiplier; 
                this.size = Math.random() * 5 + 4;
                this.color = color;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.vy += 0.05; 
                this.life -= this.decay; this.size *= 0.96; 
            }
            draw(context) {
                if (this.life <= 0) return;
                context.beginPath();
                if (this.color.startsWith('#')) {
                     context.globalAlpha = this.life;
                     context.fillStyle = this.color;
                } else {
                    context.fillStyle = this.color.replace(')', `, ${this.life})`);
                }
                context.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                context.fill();
                context.globalAlpha = 1.0;
            }
        }

        // 下落小球类
        class FallingBall {
            constructor(canvasWidth) {
                this.radius = Math.random() * 20 + 15; // 半径 15-35
                this.points = Math.floor(this.radius); // 分数等于半径
                this.x = Math.random() * (canvasWidth - 100) + 50; 
                this.y = -this.radius - 10; 
                this.vy = Math.random() * 2 + 1.5; 
                this.color = '#32CD32'; 
                this.isHit = false; 
            }
            update() { this.y += this.vy; }
            draw(context) {
                context.beginPath();
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fillStyle = this.color;
                context.shadowColor = '#00FF00';
                context.shadowBlur = this.radius / 2;
                context.fill();
                context.shadowBlur = 0;
            }
        }

        // --- 3. 核心渲染循环 (60FPS) ---
        function renderLoop() {
            if (!isRunning) return;

            // 确保画布尺寸匹配视频
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            const CW = canvasElement.width;
            const CH = canvasElement.height;

            ctx.clearRect(0, 0, CW, CH);

            // A. 绘制鼻子彗星尾巴 (底层)
            if (nosePosition) {
                for (let i = 0; i < 2; i++) {
                    tailParticles.push(new Particle(nosePosition.x, nosePosition.y, 'rgb(255, 50, 50)', 1.0));
                }
            }
            for (let i = tailParticles.length - 1; i >= 0; i--) {
                tailParticles[i].update();
                tailParticles[i].draw(ctx);
                if (tailParticles[i].life <= 0) tailParticles.splice(i, 1);
            }

            // B. 处理下落小球和碰撞逻辑
            if (Math.random() < 0.05) fallingBalls.push(new FallingBall(CW));

            for (let i = fallingBalls.length - 1; i >= 0; i--) {
                const ball = fallingBalls[i];
                ball.update();
                ball.draw(ctx);

                if (nosePosition && !ball.isHit) {
                    const dist = getDistance(nosePosition.x, nosePosition.y, ball.x, ball.y);
                    // 碰撞判定
                    if (dist < ball.radius + NOSE_RADIUS) {
                        ball.isHit = true; 
                        
                        // 1. 更新右上角总分
                        score += ball.points;
                        scoreSpan.innerText = score;

                        // 2. 在碰撞位置生成漂浮的 "+分数" 特效
                        floatingTexts.push(new FloatingText(ball.x, ball.y, ball.points));
                        
                        // 3. 生成爆炸粒子
                        for(let j=0; j < 25; j++) {
                            const randomColor = EXPLOSION_COLORS[Math.floor(Math.random() * EXPLOSION_COLORS.length)];
                            explosionParticles.push(new Particle(ball.x, ball.y, randomColor, 4.0));
                        }
                    }
                }
                // 移除出界或被击中的球
                if (ball.isHit || ball.y > CH + ball.radius) fallingBalls.splice(i, 1);
            }

            // C. 绘制爆炸粒子 (中层)
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                explosionParticles[i].update();
                explosionParticles[i].draw(ctx);
                if (explosionParticles[i].life <= 0) explosionParticles.splice(i, 1);
            }

            // D. 绘制漂浮文字 (上层)
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                floatingTexts[i].update();
                floatingTexts[i].draw(ctx);
                // 移除完全透明的文字
                if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
            }

            // E. 绘制鼻尖本体 (最顶层)
            if (nosePosition) {
                ctx.beginPath();
                ctx.arc(nosePosition.x, nosePosition.y, NOSE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            requestAnimationFrame(renderLoop);
        }

        // --- 4. MediaPipe 与控制逻辑 ---
        function onResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                messageBox.style.display = 'none';
                const nose = results.multiFaceLandmarks[0][1];
                // 更新鼻尖坐标
                nosePosition = { x: nose.x * canvasElement.width, y: nose.y * canvasElement.height };
            } else {
                nosePosition = null;
            }
        }

        async function startTracking() {
            messageBox.innerHTML = "初始化引擎中...";
            messageBox.style.display = 'block';
            
            // 重置游戏状态
            score = 0;
            scoreSpan.innerText = score;
            tailParticles = []; fallingBalls = []; explosionParticles = []; floatingTexts = [];

            // 初始化模型
            if (!faceMesh) {
                faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
                faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                faceMesh.onResults(onResults);
            }
            // 初始化摄像头
            if (!camera) {
                camera = new Camera(videoElement, {
                    onFrame: async () => { await faceMesh.send({image: videoElement}); },
                    width: 1280, height: 720
                });
            }
            try {
                await camera.start();
                videoElement.style.opacity = 1;
                isRunning = true;
                renderLoop(); // 启动渲染循环
            } catch (e) {
                alert("摄像头启动失败，请检查浏览器权限。");
                toggleBtn.checked = false;
            }
        }

        async function stopTracking() {
            isRunning = false;
            if (camera) await camera.stop();
            videoElement.style.opacity = 0;
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            messageBox.innerHTML = "请开启摄像头<br><span style='font-size:0.8em'>越大越好撞，分越高！</span>";
            messageBox.style.display = 'block';
        }

        toggleBtn.addEventListener('change', (e) => {
            if (e.target.checked) startTracking();
            else stopTracking();
        });
    </script>
</body>
</html>