<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äººè„¸è¿½è¸ª - é¼»å°–ç¢°çƒçˆ†ç‚¸æ¸¸æˆ (éŸ³æ•ˆæœ€ç»ˆç‰ˆ)</title>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #000; overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        .container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
        }
        video, canvas {
            position: absolute; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
        }
        video { z-index: 1; opacity: 0; transition: opacity 0.5s; }
        canvas { z-index: 2; }

        .center-msg {
            position: absolute; z-index: 10; top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            color: rgba(255, 255, 255, 0.9); background: rgba(0,0,0,0.6);
            padding: 20px 40px; border-radius: 12px; backdrop-filter: blur(5px);
            font-size: 1.5rem; letter-spacing: 2px; border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
        }
        .score-board {
            position: absolute; top: 30px; right: 40px; z-index: 30;
            color: #FFD700; 
            font-size: 32px; font-weight: 800;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3); padding: 10px 20px;
            border-radius: 10px; border: 1px solid rgba(255,215,0,0.3);
        }
        .control-panel {
            position: absolute; bottom: 40px; left: 40px; z-index: 20;
            background: rgba(20, 20, 20, 0.6); padding: 10px 20px;
            border-radius: 30px; backdrop-filter: blur(10px);
            display: flex; align-items: center; gap: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 22px; width: 22px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #34c759; }
        input:checked + .slider:before { transform: translateX(22px); }
        .label-text { color: white; font-size: 14px; }
    </style>
</head>
<body>

    <div class="container">
        <div class="score-board">Score: <span id="scoreVal">0</span></div>
        <div class="center-msg" id="messageBox">è¯·å¼€å¯æ‘„åƒå¤´<br><span style="font-size:0.8em">è®°å¾—æ‰“å¼€ç”µè„‘éŸ³é‡ï¼</span></div>
        <video id="inputVideo" playsinline></video>
        <canvas id="outputCanvas"></canvas>
    </div>

    <div class="control-panel">
        <label class="switch">
            <input type="checkbox" id="toggleBtn">
            <span class="slider"></span>
        </label>
        <span class="label-text">å¼€å§‹æ¸¸æˆ</span>
    </div>

    <script>
        const videoElement = document.getElementById('inputVideo');
        const canvasElement = document.getElementById('outputCanvas');
        const ctx = canvasElement.getContext('2d');
        const toggleBtn = document.getElementById('toggleBtn');
        const messageBox = document.getElementById('messageBox');
        const scoreSpan = document.getElementById('scoreVal');

        let faceMesh, camera;
        let isRunning = false;
        let nosePosition = null; 
        const NOSE_RADIUS = 15; 
        let score = 0;

        const EXPLOSION_COLORS = ['#FFD700', '#FF4500', '#00BFFF', '#FF1493', '#7FFF00', '#9400D3'];

        let tailParticles = [];      
        let fallingBalls = [];       
        let explosionParticles = []; 
        let floatingTexts = [];

        // --- ğŸµ éŸ³æ•ˆç³»ç»Ÿ (Web Audio API) ---
        // è¿™ç§æ–¹å¼ä¸éœ€è¦å¼•å…¥å¤–éƒ¨ mp3 æ–‡ä»¶ï¼Œç›´æ¥ç”¨ä»£ç ç”Ÿæˆå£°éŸ³
        let audioCtx;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playHitSound() {
            if (!audioCtx) return;
            // å¦‚æœéŸ³é¢‘ä¸Šä¸‹æ–‡è¢«æµè§ˆå™¨æŒ‚èµ·ï¼ˆä¸ºäº†çœç”µï¼‰ï¼Œéœ€è¦æ¢å¤
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // è®¾ç½®éŸ³è‰²ï¼šsine (æ­£å¼¦æ³¢, æŸ”å’Œ), square (æ–¹æ³¢, åƒ8-bitæ¸¸æˆ), triangle (ä¸‰è§’æ³¢)
            oscillator.type = 'sine'; 
            
            // è®¾ç½®é¢‘ç‡ï¼šä» 800Hz æ»‘å‘ 1200Hz (äº§ç”Ÿä¸€ç§â€œDingâ€çš„ä¸Šæ‰¬æ„Ÿ)
            // ç¨å¾®åŠ ä¸€ç‚¹éšæœºæ€§ï¼Œè®©æ¯æ¬¡å£°éŸ³ä¸å®Œå…¨æ­»æ¿
            const startFreq = 800 + Math.random() * 200;
            oscillator.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(startFreq + 400, audioCtx.currentTime + 0.1);

            // è®¾ç½®éŸ³é‡ï¼šå¿«é€Ÿæ·¡å‡º
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.15);
        }


        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }

        // --- ç±»å®šä¹‰ ---
        class FloatingText {
            constructor(x, y, points) {
                this.x = x; this.y = y;
                this.text = "+" + points;
                this.life = 1.0; this.vy = -3; 
            }
            update() { this.y += this.vy; this.life -= 0.02; }
            draw(context) {
                if (this.life <= 0) return;
                context.save();
                context.translate(this.x, this.y);
                context.scale(-1, 1); 
                context.font = "bold 28px Arial";
                context.textAlign = "center"; 
                context.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                context.strokeStyle = `rgba(0, 0, 0, ${this.life * 0.5})`;
                context.lineWidth = 3;
                context.strokeText(this.text, 0, 0);
                context.fillText(this.text, 0, 0);
                context.restore(); 
            }
        }

        class Particle {
            constructor(x, y, color, speedMultiplier = 1.0) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 5 * speedMultiplier;
                this.vy = (Math.random() - 0.5) * 5 * speedMultiplier;
                this.life = 1.0; 
                this.decay = (Math.random() * 0.02 + 0.01) * speedMultiplier; 
                this.size = Math.random() * 5 + 4;
                this.color = color;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.vy += 0.05; 
                this.life -= this.decay; this.size *= 0.96; 
            }
            draw(context) {
                if (this.life <= 0) return;
                context.beginPath();
                if (this.color.startsWith('#')) {
                     context.globalAlpha = this.life;
                     context.fillStyle = this.color;
                } else {
                    context.fillStyle = this.color.replace(')', `, ${this.life})`);
                }
                context.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                context.fill();
                context.globalAlpha = 1.0;
            }
        }

        class FallingBall {
            constructor(canvasWidth) {
                this.radius = Math.random() * 20 + 15; 
                this.points = Math.floor(this.radius); 
                this.x = Math.random() * (canvasWidth - 100) + 50; 
                this.y = -this.radius - 10; 
                this.vy = Math.random() * 2 + 1.5; 
                this.color = '#32CD32'; 
                this.isHit = false; 
            }
            update() { this.y += this.vy; }
            draw(context) {
                context.beginPath();
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fillStyle = this.color;
                context.shadowColor = '#00FF00';
                context.shadowBlur = this.radius / 2;
                context.fill();
                context.shadowBlur = 0;
            }
        }

        // --- æ¸²æŸ“å¾ªç¯ ---
        function renderLoop() {
            if (!isRunning) return;

            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            const CW = canvasElement.width;
            const CH = canvasElement.height;

            ctx.clearRect(0, 0, CW, CH);

            if (nosePosition) {
                for (let i = 0; i < 2; i++) {
                    tailParticles.push(new Particle(nosePosition.x, nosePosition.y, 'rgb(255, 50, 50)', 1.0));
                }
            }
            for (let i = tailParticles.length - 1; i >= 0; i--) {
                tailParticles[i].update();
                tailParticles[i].draw(ctx);
                if (tailParticles[i].life <= 0) tailParticles.splice(i, 1);
            }

            if (Math.random() < 0.05) fallingBalls.push(new FallingBall(CW));

            for (let i = fallingBalls.length - 1; i >= 0; i--) {
                const ball = fallingBalls[i];
                ball.update();
                ball.draw(ctx);

                if (nosePosition && !ball.isHit) {
                    const dist = getDistance(nosePosition.x, nosePosition.y, ball.x, ball.y);
                    if (dist < ball.radius + NOSE_RADIUS) {
                        ball.isHit = true; 
                        
                        score += ball.points;
                        scoreSpan.innerText = score;

                        // ğŸ”¥ è§¦å‘éŸ³æ•ˆ
                        playHitSound();

                        floatingTexts.push(new FloatingText(ball.x, ball.y, ball.points));
                        
                        for(let j=0; j < 25; j++) {
                            const randomColor = EXPLOSION_COLORS[Math.floor(Math.random() * EXPLOSION_COLORS.length)];
                            explosionParticles.push(new Particle(ball.x, ball.y, randomColor, 4.0));
                        }
                    }
                }
                if (ball.isHit || ball.y > CH + ball.radius) fallingBalls.splice(i, 1);
            }

            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                explosionParticles[i].update();
                explosionParticles[i].draw(ctx);
                if (explosionParticles[i].life <= 0) explosionParticles.splice(i, 1);
            }

            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                floatingTexts[i].update();
                floatingTexts[i].draw(ctx);
                if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
            }

            if (nosePosition) {
                ctx.beginPath();
                ctx.arc(nosePosition.x, nosePosition.y, NOSE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            requestAnimationFrame(renderLoop);
        }

        function onResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                messageBox.style.display = 'none';
                const nose = results.multiFaceLandmarks[0][1];
                nosePosition = { x: nose.x * canvasElement.width, y: nose.y * canvasElement.height };
            } else {
                nosePosition = null;
            }
        }

        async function startTracking() {
            // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
            initAudio();
            // åœ¨ç”¨æˆ·äº¤äº’ï¼ˆç‚¹å‡»å¼€å…³ï¼‰æ—¶æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼Œå¦åˆ™æµè§ˆå™¨ä¼šé™éŸ³
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            messageBox.innerHTML = "åˆå§‹åŒ–ä¸­...";
            messageBox.style.display = 'block';
            
            score = 0;
            scoreSpan.innerText = score;
            tailParticles = []; fallingBalls = []; explosionParticles = []; floatingTexts = [];

            if (!faceMesh) {
                faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
                faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                faceMesh.onResults(onResults);
            }
            if (!camera) {
                camera = new Camera(videoElement, {
                    onFrame: async () => { await faceMesh.send({image: videoElement}); },
                    width: 1280, height: 720
                });
            }
            try {
                await camera.start();
                videoElement.style.opacity = 1;
                isRunning = true;
                renderLoop(); 
            } catch (e) {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ã€‚");
                toggleBtn.checked = false;
            }
        }

        async function stopTracking() {
            isRunning = false;
            if (camera) await camera.stop();
            videoElement.style.opacity = 0;
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            messageBox.innerHTML = "è¯·å¼€å¯æ‘„åƒå¤´<br><span style='font-size:0.8em'>è®°å¾—æ‰“å¼€ç”µè„‘éŸ³é‡ï¼</span>";
            messageBox.style.display = 'block';
        }

        toggleBtn.addEventListener('change', (e) => {
            if (e.target.checked) startTracking();
            else stopTracking();
        });
    </script>
</body>
</html>